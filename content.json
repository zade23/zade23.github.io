{"meta":{"title":"ANdRoid's BLOG","subtitle":"MaTRix","description":"","author":"Android","url":"https://zade23.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-05-18T08:34:11.674Z","updated":"2023-05-18T08:34:11.674Z","comments":false,"path":"about/index.html","permalink":"https://zade23.github.io/about/index.html","excerpt":"","text":"Android，单机游戏(尤其是魂类)爱好者，游戏行业的一名算法工程师，现居广东 感兴趣的技术：扩散模型、神经网络架构、交互式深度学习、计算机图形学"},{"title":"标签","date":"2023-05-18T08:07:04.950Z","updated":"2023-05-18T08:07:04.950Z","comments":false,"path":"tags/index.html","permalink":"https://zade23.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-05-18T03:53:31.018Z","updated":"2023-05-18T03:53:31.018Z","comments":false,"path":"repository/index.html","permalink":"https://zade23.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-05-18T08:06:17.850Z","updated":"2023-05-18T08:06:17.850Z","comments":false,"path":"categories/index.html","permalink":"https://zade23.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"工具网站","slug":"工具网站","date":"2023-10-18T09:04:52.000Z","updated":"2023-10-18T09:11:56.955Z","comments":true,"path":"2023/10/18/工具网站/","link":"","permalink":"https://zade23.github.io/2023/10/18/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/","excerpt":"","text":"内容分类 学习资源网站 AIGC LLM TTS RL Diffusion Huggingface Awesome 数学基础 机器学习 深度学习&#x2F;模型训练 抽象概念可视化 传统算法 汇编语言 电子书 工具网站 在线大语言模型 在线API 数据集 音频处理 视频处理 图像处理 设计 下载工具 格式压缩 内容分类学习资源网站AIGC 【关于AIGC的各种精选教程和资源，既适合初学者也适合进阶AI爱好者】github.com&#x2F;luban-agi&#x2F;Awesome-AIGC-Tutorials&#x2F;blob&#x2F;main&#x2F;README_zh.md LLM 【收集各种垂直领域的大语言模型】Awesome Domain LLM 【关于大型语言模型(LLM)的一切，包括了LLMs的入门、微调方法、多模态模型、稳定扩散、注意力机制优化和数据效率等方面的信息，从nanoGPT到LoRA、QLoRA、RLHF到CLIP等多模态模型】Everything-about-LLMs 【提示工程实例：用实际项目学习提示工程技术，从大型语言模型获得更好的结果，内容涵盖零样本和少样本提示，分隔符，步骤编号，角色提示，思维链(CoT)提示等】 《Prompt Engineering: A Practical Example – Real Python》 TTS 【如何在浏览器中处理音视频】Web 音视频系列 【基于华为诺亚方舟实验室Grad-TTS的Grad-SVC】https://github.com/PlayVoice/Grad-SVC 【台大课程《深度学习音乐分析与生成》资料】 github.com&#x2F;affige&#x2F;DeepMIR 【大型音频模型相关文献资源列表】 github.com&#x2F;EmulationAI&#x2F;awesome-large-audio-models RL 【Generative Agents with Llama2】https://github.com/rlancemartin/generative_agents Diffusion 【扩散模型相关论文资源列表，涵盖了文本到视频生成、文本引导视频编辑、个性化视频生成、视频预测等方面】 github.com&#x2F;ChenHsing&#x2F;Awesome-Video-Diffusion-Models 【3D Diffusion相关文献列表】 github.com&#x2F;cwchenwang&#x2F;awesome-3d-diffusion Huggingface 【Hugging Face - Learn】https://huggingface.co/learn Awesome 【收集各种生成式 AI 的教程】Awesome AIGC Tutorials 数学基础 【给程序员的线性代数指南】Linear Algebra for programmers 机器学习 【ML Papers Explained：机器学习论文解析】 github.com&#x2F;dair-ai&#x2F;ML-Papers-Explained 深度学习&#x2F;模型训练 【Batched LoRAs：通过同一批次的多个 LoRA 路由推理，最大化 GPU 利用率】Batched LoRAs - batched 抽象概念可视化 【机器学习MachineLearning】www.r2d3.us 【波Waveforms】Let’s Learn About Waveforms 传统算法 【开源算法库Algorithms】The Algorithms 汇编语言 Python 【Python官方文档】Python语法官方文档 【从Python内置函数理解Python】Understanding all of Python, through its builtins 【GraphLearn-for-PyTorch(GLT)：PyTorch图学习库，使分布式 GNN 训练和推理变得简单高效】’GraphLearn-for-PyTorch(GLT) A graph learning library for PyTorch that makes distributed GNN training and inference easy and efficient C++ 【C++在线学习】Learn C++ – Skill up with our free tutorials 电子书 (图书馆)【zlibrary】Z-Library – the world’s largest e-book library. Your gateway to knowledge and culture. 【免费书《人工智能：计算Agent基础，(第三版)》】《Artificial Intelligence: Foundations of Computational Agents, 3rd Edition》David L. Poole and Alan K. Mackworth (2023) 【配有动画的数据结构与算法电子书】Hello 算法 工具网站在线大语言模型 百度（文心一言） 抖音（云雀大模型） 智谱AI（GLM大模型） 中科院（紫东太初大模型） 百川智能（百川大模型） ChatGPT Poe 讯飞星火 谷歌bard 阿里通义千问 在线API 【收集各种 AI 工具和资源】AIHub 【免费AI API列表】free-ai-apis 【作文批改：使用GPT4对雅思托福作文判分和批改】https://www.essay.art/ 数据集 【OpenDataLab 为国产大模型提供高质量的开放数据集】OpenDataLab 音频处理 【Whisper:英语音频转成文本的在线工具】Whisper Web 视频处理 【Spikes Studio】https://spikes.studio/ 图像处理 【在线体验-图像分割算法Meta-SegementAnything】Segment Anything 【SDXL在线体验】StableDiffusion XL 体验站 【nutsh：旨在通过人工反馈进行视觉学习的平台，具有用户友好的界面和 API，支持一系列视觉模式、多样化的人工输入方法以及基于人工反馈的学习机制】Nutsh 设计 【中文的图标搜索引擎，作者利用 ChatGPT 翻译了 Iconify 的 18 万个图标名】yesicon 【JupyterCAD - 用于3D几何建模的JupyterLab扩展】https://github.com/QuantStack/jupytercad 【图标搜索引擎收入了10万+的图标】Iconbuddy — 180K+ open source icons 【AI漫画|可选择漫画风格和页面布局】AI Comic Factory - a Hugging Face Space by jbilcke-hf 【Figma在线版】Figma 下载工具 【YouTube视频解析下载 】snapsave.io 【bilibili视频下载】bili.iiilab 格式压缩 【图片压缩软件】Topspeed Image Compressor 在线压缩","categories":[],"tags":[{"name":"工具网站","slug":"工具网站","permalink":"https://zade23.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"}]},{"title":"Python元组集合字典","slug":"Python元组集合字典","date":"2023-10-18T08:20:18.000Z","updated":"2023-10-18T08:56:33.797Z","comments":true,"path":"2023/10/18/Python元组集合字典/","link":"","permalink":"https://zade23.github.io/2023/10/18/Python%E5%85%83%E7%BB%84%E9%9B%86%E5%90%88%E5%AD%97%E5%85%B8/","excerpt":"","text":"1. 元组 1.1 元组的初始化 1.2 元组的解包 1.3 元组的其他操作 2. 集合 2.1 集合的初始化 2.2 集合的常用操作 2.3 使用for循环遍历集合 3. 字典 3.1 字典的初始化 3.2 字典的常用操作 3.3 使用for循环遍历字典 1. 元组元组跟 列表 类似，只是不支持动态添加、删除元素，以及不能修改元素。 1.1 元组的初始化元组需要用小括号括起来，中间的元素用逗号隔开。 注意:如果初始化只包含一个元素的元组，需要在该元素后添加逗号。 1234567a = () # 初始化一个空元组b = (1, 2) # 含有2个整数的元组c = 6, &quot;Python&quot;, 3.14 # 小括号可以省略，等价于(6, &quot;Python&quot;, 3.14)d = (5,) # 注意不能写成(5)，(5)表示整数5e = 5, # 等价于(5,)print(a, b, c, d, e) 1.2 元组的解包123t = 12345, 54321, &quot;Hello!&quot; # 初始化一个元组x, y, z = t # 将元组解包，将元组内的三个值按顺序赋值给x、y、zprint(x, y, z) 所以，判断语句中的交换操作，本质上是元组的解包： 12a, b = 3, 4 # 将元组(3, 4)解包，分别赋值给a、ba, b = b, a # 将元组(b, a)解包，分别赋值给a、b 同样地，函数中函数返回多个值，本质上也是返回了一个元组： 1234567def calc(x, y): return x + y, x * y # 等价于 return (x + y, x * y)x, y = 3, 4s, p = calc(x, y) # 将(x + y, x * y)解包，分别赋值给s、pprint(s, p) 1.3 元组的其他操作元组的下标访问元素、循环遍历、切片、加法和乘法运算等操作，都与列表相同。 2. 集合集合是Python中最常用的数据结构之一，用来存储不同元素。注意，集合中的元素是无序的。 2.1 集合的初始化创建集合用花括号或set()函数。注意：创建空集合只能用set()，不能用&#123;&#125;，因为&#123;&#125;创建的是空字典，会在下一小节里介绍字典。 集合常见的初始化方式： 123456789101112131415basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125; # 会自动去除重复元素print(basket) # 重复的元素已经去除了s = set() # 初始化一个空列表print(s)a = [1, 2, 1, 3, 1]b = set(a) # 将列表转化成集合，一般是为了去重。c = list(b) # 将集合转化回列表print(b, c)x = &quot;abracadabra&quot;a = set(x) # 将字符串中的每个字符存到集合中b = str(a) # 注意，这里并不能将集合转化回原字符串，而是用格式化表示集合中的内容print(a, b) 2.2 集合的常用操作假设a表示一个集合。 12345len(a) 返回集合中包含的元素数量。a.add(x) 在集合中添加一个元素。a.remove(x) 删除集合中的x，如果x不存在，则报异常。a.discard(x) 删除集合中的x，如果x不存在，则不进行任何操作。x in a 判断x是否在a中。 例如： 1234567891011121314a = &#123;1, 2, 3&#125;print(len(a)) # 输出3a.add(4)print(a) # 输出 &#123;1, 2, 3, 4&#125;，注意集合中的元素是无序的。a.remove(2)print(a) # 输出 &#123;1, 3, 4&#125;a.remove(5) # 因为5不存在，所以会报异常a.discard(5) # 因为5不存在，所以不进行任何操作print(a) # &#123;1, 3, 4&#125; 2.3 使用for循环遍历集合类似于列表，集合也可以用for ... in ...的形式遍历。例如： 1234a = &#123;1, 2, 3&#125;for x in a: # 循环遍历整个集合 print(x, end=&#x27; &#x27;) 3. 字典字典是Python中最常用的数据结构之一，用来存储映射关系。注意，字典中的元素是无序的。 不同于列表，字典是以key进行索引的，可以将每个key映射到某个value。key可以是任何不可变类型，常用可以作为key的类型有数字和字符串。列表因为是可变的，所以不能作为key。value可以是任意类型。 3.1 字典的初始化3.2 字典的常用操作3.3 使用for循环遍历字典","categories":[],"tags":[]},{"title":"Python字符串","slug":"Python字符串","date":"2023-10-18T08:18:06.000Z","updated":"2023-10-18T08:40:42.964Z","comments":true,"path":"2023/10/18/Python字符串/","link":"","permalink":"https://zade23.github.io/2023/10/18/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"1. 字符与整数的联系——ASCII码 2. 字符串常量的写法 3. 表示特殊字符——转义 4. 访问字符串中的每个字符 5. 使用循环语句遍历字符串 6. 字符串的切片操作 7. 字符串的复制 8. 字符串的运算 9. 字符串的常用操作 10. 更复杂的格式化输出 11. 作业题扩展内容 1. 字符与整数的联系——ASCII码每个常用字符都对应一个-128 ~ 127的数字，二者之间可以相互转化。注意：目前负数没有与之对应的字符。 ord()函数可以求一个字符的ASCII码。注意输入是一个字符，而不是字符串。 chr()函数可以将一个ASCII码转化成对应的字符。 12345c = &#x27;a&#x27;print(ord(c))a = 66print(chr(a)) 常用ASCII值：&#39;A&#39;- &#39;Z&#39;是65 ~ 90，&#39;a&#39; - &#39;z&#39;是97 - 122，0 - 9是48 - 57。 注意：虽然字符可以跟整数相互转化，但在Python中，字符不能参与数值运算，这一点跟C++、Java等语言是不同的。 2. 字符串常量的写法在Python中，字符串既可以用单引号来表示，也可以用双引号来表示，二者完全相同。这一点跟C++、Java等编程语言是不同的，在这些编程语言中，用单引号来表示字符，用双引号来表示字符串。 12345a = &quot;Hello World&quot; # 双引号写法print(a)b = &#x27;Hello World&#x27; # 单引号写法print(b) 两个或多个字符串常量并排写，会被自动合并，例如： 12a = &quot;My &quot; &quot;name &quot; &quot;is yxc.&quot;print(a) # 输出：My name is yxc. 一个字符串如果包含多行，可以采用&quot;&quot;&quot;...&quot;&quot;&quot;或者&#39;&#39;&#39;...&#39;&#39;&#39;的初始化方式，字符串中将自动包含回车字符，例如： 1234a = &quot;&quot;&quot;Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to&quot;&quot;&quot;print(a) 会得到如下输出： 123Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to 3. 表示特殊字符——转义当想在字符串中表示特殊字符时，一般可以在字符前加反斜杠\\。 常见需要转义的字符有： 转义字符 含义 ASCII码（十进制） \\n 回车 10 `` 代表一个反斜杠\\ 92 `“&#96; 表示一个双引号 34 `‘&#96; 表示一个单引号 39 例如： 1print(&quot;My name is:\\n\\&quot;yxc!\\&quot;&quot;) 会得到如下输出： 12My name is:&quot;yxc!&quot; 另外，如果想输出单引号，也可以用双引号来表示，反之亦然。例如： 12print(&quot;My name is &#x27;yxc!&#x27;&quot;) # 输出：My name is &#x27;yxc!&#x27;print(&#x27;My name is &quot;yxc!&quot;&#x27;) # 输出：My name is &quot;yxc!&quot; 4. 访问字符串中的每个字符可以通过下标读取字符串中的每个字符，下标从0开始，也可以是负数，负数下标表示的是除以字符串长度的余数对应的位置。 负数下标相当于将字符串首位相接，然后从0往前数。 如果字符串长度是 nn，那么下标只能取 −n∼n−1−n∼n−1 之间的整数，超出范围会报错。 注意：字符串中的每个字符不能修改。 例如： 1234a = &quot;Hello World&quot;print(a[0], ord(a[5])) # 输出H 32a[2] = &#x27;x&#x27; # 会报错，字符串不能修改 5. 使用循环语句遍历字符串可以通过下标访问，例如： 1234s = &quot;acwing&quot;for i in range(6): print(s[i], end=&#x27; &#x27;)print() # 输出回车 可以通过for ... in ...直接遍历，例如： 123for c in &quot;python&quot;: print(c, end=&#x27; &#x27;) # 注意c本身也是字符串类型print() # 输出回车 6. 字符串的切片操作字符串的切片操作会返回一个新字符串。用法： a[begin:end] 会返回包含a[begin], a[begin + 1], ..., a[end - 1]的字符串。 省略begin时，begin的默认值是0。 省略end时，end的默认值是字符串长度。 如果begin或end是负数，表示的是除以字符串长度后的余数。 例如： 1234567a = &quot;ABCDE&quot;print(a[1:4]) # 输出BCDprint(a[1:]) # 输出BCDEprint(a[:4]) # 输出ABCDprint(a[:]) # 输出ABCDEprint(a[-4:-1]) # 等价于print(a[1:4]) 注意：字符串的切片不支持写操作。 例如： 12a = &quot;ABCDE&quot;a[1:4] = &quot;XY&quot; # 会报错，字符串不能修改 7. 字符串的复制跟列表不同，字符串的每次复制操作，都会得到一个全新的字符串。 8. 字符串的运算 字符串的加法可以将两个字符串拼接起来，得到一个新字符串。 字符串乘以一个整数，可以将若干个自身拼接起来，得到一个新字符串。 字符串支持比较运算符，按字典序比较大小。即如果两个字符串相同，则表示相等；否则找到两个字符串从左到右数第一个不一样的字符，哪个字符串的字符的ASCII码小，哪个字符串的字典序就小；另外空字符比任何字符都小。 例如： 12345678910111213a = &quot;Hello &quot;b = &quot;World&quot;c = a + bprint(c) # 输出Hello Worldd = a * 3print(d) # 输出Hello Hello Helloe = a * 3 + &quot;World&quot;print(e) # 输出Hello Hello Hello Worldprint(a &lt;= b) # 按字典序比较大小，输出Trueprint(&quot;123&quot; &gt; &quot;22&quot;) # 按字典序比较大小，输出False 9. 字符串的常用操作假设s是一个字符串，则： len(s)返回字符串长度。 s.split(sep)返回一个字符串列表。如果给出了sep就按sep分隔；如果没给出，则会按空格分隔，但连续的空格会被视为单个分隔符，而且会忽略首尾的空白字符。 s.strip()将首尾的空白字符删除。 s.replace(old, new)将s中所有的old子串都改成new。 s.find(&quot;abc&quot;)查询某个子串在s中第一次出现的下标；如果不存在，则返回-1。 s.startswith(prefix)判断prefix是否为s的前缀。 s.endswith(suffix)判断suffix是否为s的后缀。 s.lower()将所有大写字母变成小写。 s.upper()将所有小写字母变成大写。 s.join(a)，a是一个字符串列表，这个函数返回将a中的字符用s作为分隔符拼接起来的结果。 注意：返回的所有字符串都是新字符串，原字符串不变。 例如： 123456789101112131415161718s1 = &quot;abc def xyz&quot;print(len(s1)) # 输出11print(s1.split()) # 输出[&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;xyz&#x27;]s2 = &quot; abc abc &quot;print(s2.strip()) # 输出abc abcprint(s2.replace(&quot;abc&quot;, &quot;*&quot;)) # 输出 * *print(s2.find(&quot;abc&quot;), s2.find(&quot;xyz&quot;)) # 输出2 -1s3 = &quot;Abc deF&quot;print(s3.startswith(&quot;Ab&quot;)) # 输出Trueprint(s3.endswith(&quot;deF&quot;)) # 输出Trueprint(s3.lower()) # 输出abc defprint(s3.upper()) # 输出ABC DEFs4 = &quot;, &quot;a = [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]print(s4.join(a)) # 输出aa, bb, cc 10. 更复杂的格式化输出当需要用到更复杂的格式化输出时，现查即可。可以参考： 更复杂的输出格式 printf 风格的字符串格式化 11. 作业题扩展内容 作业的评测器会自动忽略每一行的行末空格，所以行末输出多余空格也视为正确。 s.isdigit()：当字符串s不是空字符串，且包含的所有字符都是数字时返回True，否则返回False。 a, b = [&quot;abc&quot;, &quot;def&quot;]这种写法可以将&quot;abc&quot;赋值给第一个变量a，将&quot;def&quot;赋值给第二个变量b。 s.rfind(&quot;abc&quot;)查询某个子串在s中最后一次出现的下标；如果不存在，则返回-1。 当不知道读入的具体行数时，可以采用如下方法一次性读取所有行： 1234from sys import stdinfor line in stdin.readlines(): print(line.strip()) # strip()是为了去掉行末的回车","categories":[],"tags":[]},{"title":"学习笔记——PyTorch源码教程与前沿人工智能算法复现讲解","slug":"PyTorch源码教程与前沿人工智能算法复现讲解","date":"2023-10-16T06:47:15.000Z","updated":"2023-10-18T08:17:38.401Z","comments":true,"path":"2023/10/16/PyTorch源码教程与前沿人工智能算法复现讲解/","link":"","permalink":"https://zade23.github.io/2023/10/16/PyTorch%E6%BA%90%E7%A0%81%E6%95%99%E7%A8%8B%E4%B8%8E%E5%89%8D%E6%B2%BF%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E5%A4%8D%E7%8E%B0%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"学习笔记目录 第一章 Pytorch介绍和Tensor的创建","categories":[],"tags":[]},{"title":"经济学——流动性陷阱","slug":"经济学——流动性陷阱","date":"2023-10-16T02:37:26.000Z","updated":"2023-10-16T02:37:51.085Z","comments":true,"path":"2023/10/16/经济学——流动性陷阱/","link":"","permalink":"https://zade23.github.io/2023/10/16/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E2%80%94%E2%80%94%E6%B5%81%E5%8A%A8%E6%80%A7%E9%99%B7%E9%98%B1/","excerpt":"","text":"","categories":[],"tags":[{"name":"经济学小知识","slug":"经济学小知识","permalink":"https://zade23.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"Python函数","slug":"Python函数","date":"2023-10-12T10:22:54.000Z","updated":"2023-10-18T08:18:10.458Z","comments":true,"path":"2023/10/12/Python函数/","link":"","permalink":"https://zade23.github.io/2023/10/12/Python%E5%87%BD%E6%95%B0/","excerpt":"","text":"1. 函数基础 1.1 编写函数 1.2 调用函数 1.3 形参和实参 1.3.1 形参的初始化方式 1.3.2 带默认值的形参 1.3.3 其它参数写法 1.4 变量的作用域 2. 参数传递 2.1 值传递 2.2 引用传递 3.return语句 4.lambda表达式 5. 函数递归 Python中函数的用法非常多，80%的用法不常用，20%的用法常用。大家不要把精力浪费在背完所有用法上，而要把主要精力放到最常用的20%的用法和代码逻辑上，至于另外80%不常用的用法，边用边查就行。 1. 函数基础Python中一个典型的函数定义包括以下部分：关键字def、函数名称、由0个或多个形参组成的列表以及函数体。 1.1 编写函数我们来编写一个求阶乘的函数。例如： 12345def fact(n): res = 1 for i in range(1, n + 1): res *= i return res 函数名称是fact，给它传入一个n，会返回n的阶乘。return语句负责结束函数并返回res的值。 1.2 调用函数123print(&quot;我们要计算5的阶乘，答案是：&quot;)print(fact(5)) # 输出 120print(&quot;计算结束啦！&quot;) 函数的调用完成两项工作： 用实参初始化函数对应的形参 将控制权转移给被调用的函数 此时，代码原本的执行顺序被暂时中断，被调函数开始执行。等被调用函数执行完后，再继续执行之前的代码。 1.3 形参和实参实参指调用函数时传入的变量或常量，形参指定义函数时参数列表里的变量。 形参列表可以为空，例如： 1234def f(): print(&quot;Hello World&quot;)f() # 输出 Hello World 1.3.1 形参的初始化方式调用函数时会用实参去初始化形参，初始化的顺序有两种： 第一种是用位置实参来初始化形参。顾名思义，实参会按位置关系来初始化形参，第一个实参初始化第一个形参，第二个实参初始化第二个形参，依此类推。形参和实参的个数必须匹配。例如： 123456789def f(a, b, c, d): print(&quot;a =&quot;, a, end=&quot;, &quot;) print(&quot;b =&quot;, b, end=&quot;, &quot;) print(&quot;c =&quot;, c, end=&quot;, &quot;) print(&quot;d =&quot;, d)f(1, True, &quot;Python&quot;, 4.2) # 输出 a = 1, b = True, c = Python, d = 4.2f(1, True, &quot;Python&quot;, 4.2, 3) # 会报错，因为实参个数多于形参f(1, True, &quot;Python&quot;) # 会报错，因为实参个数少于形参 第二种是用关键字实参来初始化形参。此时实参不再按位置关系来初始化形参，而是按变量名初始化。例如： 12# f()的定义如上所述f(b=1, c=True, a=&quot;Python&quot;, d=4.2) # 输出 a = Python, b = 1, c = True, d = 4.2 两种方式也可以混合使用，但是位置实参一定要放到关键字实参之前。例如： 123# f()的定义如上所述f(1, 2, d=&quot;Python&quot;, c=4.2) # 输出 a = 1, b = 2, c = 4.2, d = Pythonf(1, b=3, &quot;Python&quot;, d=4.2) # 会报错，因为位置实参位于关键字实参后面了。 1.3.2 带默认值的形参形参也可以设置默认值，但所有带默认值的形参必须是最后几个。当某些形参没有被初始化时，这些形参会使用默认值。例如： 123456789def f(a, b, c=3, d=&quot;Python&quot;): print(&quot;a =&quot;, a, end=&quot;, &quot;) print(&quot;b =&quot;, b, end=&quot;, &quot;) print(&quot;c =&quot;, c, end=&quot;, &quot;) print(&quot;d =&quot;, d)f(1, 2) # c和d没有被初始化，采用默认值。输出 a = 1, b = 2, c = 3, d = Pythonf(1, b=2, d=&quot;AcWing&quot;) # c没有被初始化，采用默认值。输出 a = 1, b = 2, c = 3, d = AcWing 1.3.3 其它参数写法其它参数写法用得不多，想了解的同学可以参考函数定义详解。 1.4 变量的作用域函数内定义的变量为局部变量，只能在函数内部使用。 当需要修改用全局变量时，需要用global关键字在函数内声明全局变量。例如： 12345678910111213x = 1def f(): global x # 在函数内声明全局变量 x = 666 y = 777 print(x, y)f() # 输出 666 777print(x) # 会发现全局变量x也被修改了print(y) # 会报错，因为y是局部变量，函数外无法使用 1.5 嵌套定义函数函数内部也可以定义函数。例如： 12345678def f(): def g(x): # 定义函数g() x += 1 print(x) g(5) # 调用函数g()f() # 输出6 1.6 pass语句当函数定义完但还不想实现时，可以用pass占位符，来避免出现语法错误。例如： 12def f(): pass 2. 参数传递2.1 值传递int、float、bool、字符串等采用值传递。 将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。例如： 12345678def f(y): y = 5 print(y)x = 10f(x)print(x) # 会发现x的值没变 2.2 引用传递列表采用引用传递。 将实参的引用传给形参，此时对形参的修改会影响实参的初始值。例如： 12345678def f(b): for i in range(len(b)): b[i] += 1a = [0, 1, 2, 3, 4]f(a)print(a) # 会发现列表a中的每个数加了1 3.return语句return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方，并返回结果。例如： 1234567891011121314def f(x): if x == 1: return # 不写返回值时，会返回None if x == 2: return 3 # 返回一个变量 if x == 3: return 4, 5 # 返回多个变量a = f(1)b = f(2)c, d = f(3)e = f(4) # 没写return时，也会返回Noneprint(a, b, c, d, e) # 输出 None 3 4 5 None 4.lambda表达式lambda关键字可以创建匿名函数，目的是为了简化代码。可以对比下面两种写法，会发现lambda表达式的写法更短一些。 常与sort()函数配合使用，例如： 1234pairs = [[1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [4, &quot;four&quot;]]pairs.sort(key=lambda pair: pair[1]) # 每个元素使用第二个变量比较大小print(pairs) # 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]] 等价于下面的写法： 123456789pairs = [[1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [4, &quot;four&quot;]]def compare(pair): return pair[1]pairs.sort(key=compare) # 每个元素使用第二个变量比较大小print(pairs) # 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]] 5. 函数递归在一个函数内部，也可以调用函数自身。这种写法被称为递归。 写递归函数可以从集合的角度来思考。理解递归函数的执行顺序可以用树的形式来思考。 例如，求解斐波那契数列第 nn 项可以采用如下写法： 1234567def fib(n): if n &lt;= 2: return 1 return fib(n - 1) + fib(n - 2)print(fib(6)) # 输出 8","categories":[],"tags":[]},{"title":"github_workflow自动合并主线失败问题","slug":"githun-workflow自动合并主线失败问题","date":"2023-10-08T02:16:53.000Z","updated":"2023-10-08T02:37:06.373Z","comments":true,"path":"2023/10/08/githun-workflow自动合并主线失败问题/","link":"","permalink":"https://zade23.github.io/2023/10/08/githun-workflow%E8%87%AA%E5%8A%A8%E5%90%88%E5%B9%B6%E4%B8%BB%E7%BA%BF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/","excerpt":"","text":"github_workflow自动提交在合并主线时出现的问题介绍看到 GitHub 上的一个好玩的项目，大意就是保持个人主页的提交栏保持尝绿，看起来很有意思，于是学着构建了一个 GitHub_actions_workflow 。仓库是用来每日清晨推送 bing 的当日壁纸的，仓库为：https://github.com/zade23/auto-green 但是部署之后发现 Actions 的 合并提交 动作一直失败，报错如下： 123456789remote: Permission to zade23/auto-green.git denied to github-actions[bot].fatal: unable to access &#x27;https://github.com/zade23/auto-green.git/&#x27;: The requested URL returned error: 403Error: Invalid exit code: 128 at ChildProcess.&lt;anonymous&gt; (/home/runner/work/_actions/ad-m/github-push-action/master/start.js:30:21) at ChildProcess.emit (node:events:513:28) at maybeClose (node:internal/child_process:1100:16) at Process.ChildProcess._handle.onexit (node:internal/child_process:304:5) &#123; code: 128&#125; 问题分析分析主要问题，应试这段 The requested URL returned error: 403 。 最终在 Stack Overflow 上找到了解决办法： Permission denied to github-actions[bot]. The requested URL returned error: 403 问题解决GitHub Actions 中自动提交功能必须在对应仓库下面手动设置允许 bot 合并提交的权限，否则合并动作就会被拒绝。 启动 actions 的 repository - Settings -&gt; Action -&gt; General -&gt; Workflow permissions","categories":[],"tags":[]},{"title":"第 109 场双周赛|个人总结","slug":"第-109-场双周赛-个人总结","date":"2023-07-23T14:21:11.000Z","updated":"2023-07-23T15:06:13.202Z","comments":true,"path":"2023/07/23/第-109-场双周赛-个人总结/","link":"","permalink":"https://zade23.github.io/2023/07/23/%E7%AC%AC-109-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"第 109 场双周赛心路历程出门小聚，回到家打开网页已经过了半小时了，因此掉分了，事已至此，先看题吧…… 从大佬们的反馈上，这场是手速场，后两道题是经典dp，但是需要考虑一下枚举选哪个？选或者不选？（来自灵神算法精讲） 题目链接 可以直接从力扣那边复制粘贴过来 检查数组是否是好的 将字符串中的元音字母排序 访问数组中的位置使分数最大 将一个数字表示成幂的和的方案数 第一题——检查数组是否是好的 题目类型：Counter()函数 思路和方法：Counter()已经是LeetCode第一题的常客了，字符串和列表这种序列的题型总是可以用到它 123456789101112# 我的方法：很笨，考虑两个条件，区间长度和前n-1项是否为自然数序列，这个方法由于一开始没有考虑前者，所以wa了一次。class Solution: def isGood(self, nums: List[int]) -&gt; bool: n = len(nums) nums.sort() if n - 1 != nums[-1]: return False for i in range(1, n - 1): if i != nums[i - 1]: print([i, nums[i]]) return False return True 1# 灵神方法：Counter() 第二题——将字符串中的元音字母排序 题目类型：字符串排序 思路和方法：之前在做二分法的题目时做到过字母排序的问题，那时知道了字母是可以按照ASCII值使用sort()排序的，但是后续还是按照笨办法吧元音字母排序出来了 1234567891011121314151617181920# 我的方法class Solution: def sortVowels(self, s: str) -&gt; str: # print((ord(&#x27;a&#x27;), ord(&#x27;A&#x27;))) # print([ord(&#x27;e&#x27;), ord(&#x27;i&#x27;), ord(&#x27;o&#x27;), ord(&#x27;u&#x27;)]) n = len(s) cnt = [] for i in range(n): if s[i] == &#x27;a&#x27; or s[i] == &#x27;e&#x27; or s[i] == &#x27;i&#x27; or s[i] == &#x27;o&#x27; or s[i] == &#x27;u&#x27; or s[i] == &#x27;A&#x27; or s[i] == &#x27;E&#x27; or s[i] == &#x27;I&#x27; or s[i] == &#x27;O&#x27; or s[i] == &#x27;U&#x27;: cnt.append(s[i]) cnt.sort() t = &quot;&quot; x = 0 for c in s: if c == &#x27;a&#x27; or c == &#x27;e&#x27; or c == &#x27;i&#x27; or c == &#x27;o&#x27; or c == &#x27;u&#x27; or c == &#x27;A&#x27; or c == &#x27;E&#x27; or c == &#x27;I&#x27; or c == &#x27;O&#x27; or c == &#x27;U&#x27;: t += cnt[x] x += 1 else: t += c return t 第三题——访问数组中的位置使分数最大 题目类型：dp （待更新） 第四题——将一个数字表示成幂的和的方案数 题目类型：dp （待更新） 总结 个人做题感想之类的 dp是弱项，只有高强度的重复训练才能掌握。","categories":[],"tags":[]},{"title":"第 355 场周赛|个人总结","slug":"第-355-场周赛-个人总结","date":"2023-07-23T14:20:49.000Z","updated":"2023-07-23T14:47:50.141Z","comments":true,"path":"2023/07/23/第-355-场周赛-个人总结/","link":"","permalink":"https://zade23.github.io/2023/07/23/%E7%AC%AC-355-%E5%9C%BA%E5%91%A8%E8%B5%9B-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"第 355 场周赛心路历程一场体验不错的比赛，早起去公司做的，状态不错，所以涨分了~ 题目链接 可以直接从力扣那边复制粘贴过来 按分隔符拆分字符串 合并后数组中的最大元素 长度递增组的最大数目 树中可以形成回文的路径数 第一题——按分隔符拆分字符串 题目类型：字符串模拟 方法和思路： 活用split()函数——python在做LeetCode上的语法糖 注意空字符不输出 123456789101112# 我的解法：做了一个split()分割，再来个循环遍历split处理后的字符串，遇到字符串则不输出。class Solution: def splitWordsBySeparator(self, words: List[str], separator: str) -&gt; List[str]: ans = [] ans1 = [] for i in words: ans += i.split(separator) n = len(ans) for i in range(n): if ans[i] != &quot;&quot;: ans1.append(ans[i]) return ans1 1# 灵神做法： 第二题——合并后数组中的最大元素 题目类型：倒叙实现 思路和做法：抽象思维理解题意之后，正难则反，通过序列的最后往前加。 12345678# 我的解法：思路很朴实，只有后面的数尽可能大才能满足这个条件让最终的结果尽可能大。想明白之后通过抽象模拟即可class Solution: def maxArrayValue(self, nums: List[int]) -&gt; int: n = len(nums) for i in range(n - 2, -1, -1): if nums[i] &lt;= nums[i + 1]: nums[i] += nums[i + 1] return nums[0] 1# 灵神做法 第三题——长度递增组的最大数目 题目类型： （待更新） 第四题——树中可以形成回文的路径数 题目类型： （待更新） 总结 个人做题感想之类的 早起沉浸比赛的一天，第二题想得比较快，反而第一题在空字符串和缺失条件的情况下有些卡壳。由于第三第四题过难，导致没了区分度，很多大佬也做不出来，所以反而涨了些分。","categories":[],"tags":[]},{"title":"Python数据结构和算法","slug":"Python数据结构和算法","date":"2023-07-18T07:12:00.000Z","updated":"2023-10-12T10:42:30.797Z","comments":true,"path":"2023/07/18/Python数据结构和算法/","link":"","permalink":"https://zade23.github.io/2023/07/18/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法分析相关 复杂度计算 大 O 表示法 类 都是对数据的构成（状态）以及数据能做什么（行为）的描述。由于类的使用者只能看到数据项的状态和行为，因此类与抽象数据类型是相似的、 在面向对象编程范式中，数据项被称作 对象 一个对象就是类的一个实例。 1.内建原子数据结构 python是通过两种内建数据类型实现整数类型和浮点数类型的，相应的python类就是 int 和 float 。 列表列表 是零个或多个指向 Python 数据对象的引用的有序集合，通过在方括号内以逗号分隔的一系列值来表达。空列表就是 []。列表是异构的，这意味着其指向的数据对象不需要都是同一个类，并且这一集合可以被赋值给一个变量。下面的代码段展示了列表含有多个不同的 Python 数据对象。 元组 通常写成由括号包含并且以逗号分隔的一系列值。与序列一样，元组允许之前描述的任一操作。 列表提供的方法 方法名 用法 解释 append alist.append(item) 在列表末尾添加一个新元素 insert alist.insert(i,item) 在列表的第! i 个位置插入一个元素 pop alist.pop() 删除并返回列表中最后一个元素 pop alist.pop(i) 删除并返回列表中第 i 个位置的元素 sort alist.sort() 将列表元素排序 reverse alist.reverse() 将列表元素倒序排列 del del alist[i] 删除列表中第 i 个位置的元素 index alist.index(item) 返回 item 第一次出现时的下标 count alist.count(item) 返回 item 在列表中出现的次数 remove alist.remove(item) 从列表中移除第一次出现的 item 对应输出： 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt; myList[1024, 3, True, 6.5]&gt;&gt;&gt; myList.append(False)&gt;&gt;&gt; myList[1024, 3, True, 6.5, False]&gt;&gt;&gt; myList.insert(2,4.5)&gt;&gt;&gt; myList[1024, 3, 4.5, True, 6.5, False]&gt;&gt;&gt; myList.pop()False&gt;&gt;&gt; myList[1024, 3, 4.5, True, 6.5]&gt;&gt;&gt; myList.pop(1)3&gt;&gt;&gt; myList[1024, 4.5, True, 6.5]&gt;&gt;&gt; myList.pop(2)True&gt;&gt;&gt; myList[1024, 4.5, 6.5]&gt;&gt;&gt; myList.sort()&gt;&gt;&gt; myList[4.5, 6.5, 1024]&gt;&gt;&gt; myList.reverse()&gt;&gt;&gt; myList[1024, 6.5, 4.5]&gt;&gt;&gt; myList.count(6.5)1&gt;&gt;&gt; myList.index(4.5)2&gt;&gt;&gt; myList.remove(6.5)&gt;&gt;&gt; myList[1024, 4.5]&gt;&gt;&gt; del myList[0]&gt;&gt;&gt; myList[4.5] 字符串字符串是零个或多个字母、数字和其他符号的有序集合。这些字母、数字和其他符号被称为 字符。常量字符串值通过引号（单引号或者双引号均可）与标识符进行区分。 123456789&gt;&gt;&gt; &quot;David&quot;&#x27;David&#x27;&gt;&gt;&gt; myName = &quot;David&quot;&gt;&gt;&gt; myName[3]&#x27;i&#x27;&gt;&gt;&gt; myName*2&#x27;DavidDavid&#x27;&gt;&gt;&gt; len(myName)5 字符串提供的方法 方法名 用法 解释 center astring.center(w) 返回一个字符串，原字符串居中，使用空格填充新字符串，使其长度为 w count astring.count(item) 返回 item 出现的次数 ljust astring.ljust(w) 返回一个字符串，将原字符串靠左放置并填充空格至长度 w rjust astring.rjust(w) 返回一个字符串，将原字符串靠右放置并填充空格至长度 w lower astring.lower() 返回均为小写字母的字符串 upper astring.upper() 返回均为大写字母的字符串 find astring.find(item) 返回 item 第一次出现时的下标 split astring.split(schar) 在 schar 位置将字符串分割成子串，不填则默认分割空格和换行符 列表和字符串的区别： 列表有 可修改性 ，字符串没有 集合集（set）是由零个或多个不可修改的 Python 数据对象组成的无序集合。集不允许重复元素，并且写成由花括号包含、以逗号分隔的一系列值。空集由 set() 来表示。集是异构的，并且可以通过下面的方法赋给变量。 Python 集支持的运算 运算名 运算符 解释 成员 in 询问集中是否有某元素 长度 len 获取集的元素个数 | aset | otherset 返回一个包含 aset 与 otherset 所有元素的新集 &amp; aset &amp; otherset 返回一个包含 aset 与 otherset 共有元素的新集 - aset - otherset 返回一个集，其中包含只出现在 aset 中的元素 &lt;= aset &lt;= otherset 询问 aset 中的所有元素是否都在 otherset 中 Python 集提供的方法 方法名 用法 解释 union aset.union(otherset) 返回一个包含 aset 和 otherset 所有元素的集 intersection aset.intersection(otherset) 返回一个仅包含两个集共有元素的集 difference aset.difference(otherset) 返回一个集，其中仅包含只出现在 aset 中的元素 issubset aset.issubset(otherset) 询问 aset 是否为 otherset 的子集 add aset.add(item) 向 aset 添加一个元素 remove aset.remove(item) 将 item 从 aset 中移除 pop aset.pop() 随机移除 aset 中的一个元素 clear aset.clear() 清除 aset 中的所有元素 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; mySet&#123;False, 4.5, 3, 6, &#x27;cat&#x27;&#125;&gt;&gt;&gt; yourSet = &#123;99,3,100&#125;&gt;&gt;&gt; mySet.union(yourSet)&#123;False, 4.5, 3, 100, 6, &#x27;cat&#x27;, 99&#125;&gt;&gt;&gt; mySet | yourSet&#123;False, 4.5, 3, 100, 6, &#x27;cat&#x27;, 99&#125;&gt;&gt;&gt; mySet.intersection(yourSet)&#123;3&#125;&gt;&gt;&gt; mySet &amp; yourSet&#123;3&#125;&gt;&gt;&gt; mySet.difference(yourSet)&#123;False, 4.5, 6, &#x27;cat&#x27;&#125;&gt;&gt;&gt; mySet - yourSet&#123;False, 4.5, 6, &#x27;cat&#x27;&#125;&gt;&gt;&gt; &#123;3,100&#125;.issubset(yourSet)True&gt;&gt;&gt; &#123;3,100&#125;&lt;=yourSetTrue&gt;&gt;&gt; mySet.add(&quot;house&quot;)&gt;&gt;&gt; mySet&#123;False, 4.5, 3, 6, &#x27;house&#x27;, &#x27;cat&#x27;&#125;&gt;&gt;&gt; mySet.remove(4.5)&gt;&gt;&gt; mySet&#123;False, 3, 6, &#x27;house&#x27;, &#x27;cat&#x27;&#125;&gt;&gt;&gt; mySet.pop()False&gt;&gt;&gt; mySet&#123;3, 6, &#x27;house&#x27;, &#x27;cat&#x27;&#125;&gt;&gt;&gt; mySet.clear()&gt;&gt;&gt; mySet 字典字典 是无序结构，由相关的元素对构成，其中每对元素都由一个键和一个值组成。这种键–值对通常写成键:值的形式。字典由花括号包含的一系列以逗号分隔的键–值对表达，如下所示。 12&gt;&gt;&gt; capitals = &#123;&#x27;Iowa&#x27;:&#x27;DesMoines&#x27;,&#x27;Wisconsin&#x27;:&#x27;Madison&#x27;&#125;&gt;&gt;&gt; capitals&#123;&#x27;Wisconsin&#x27;:&#x27;Madison&#x27;, &#x27;Iowa&#x27;:&#x27;DesMoines&#x27;&#125; 可以通过键访问其对应的值，也可以向字典添加新的键–值对。访问字典的语法与访问序列的语法十分相似，只不过是使用键来访问，而不是下标。添加新值也类似。 1234567&gt;&gt;&gt; capitals[&#x27;Iowa&#x27;] = &#x27;DesMoines&#x27;&gt;&gt;&gt; capitals[&#x27;Utah&#x27;] = &#x27;SaltLakeCity&#x27;&gt;&gt;&gt; capitals&#123;&#x27;Utah&#x27;:&#x27;SaltLakeCity&#x27;, &#x27;Wisconsin&#x27;:&#x27;Madison&#x27;, &#x27;Iowa&#x27;:&#x27;DesMoines&#x27;&#125;&gt;&gt;&gt; capitals[&#x27;California&#x27;]=&#x27;Sacramento&#x27;&gt;&gt;&gt; capitals&#123;&#x27;Utah&#x27;:&#x27;SaltLakeCity&#x27;, &#x27;Wisconsin&#x27;:&#x27;Madison&#x27;, &#x27;Iowa&#x27;:&#x27;DesMoines&#x27;, &#x27;California&#x27;:&#x27;Sacramento&#x27;&#125;&gt;&gt;&gt; len(capitals)&gt;&gt;&gt; 4 需要谨记，字典并不是根据键来进行有序维护的。第一个添加的键–值对（&#39;Utah&#39;:&#39;SaltLakeCity&#39;）被放在了字典的第一位，第二个添加的键–值对（&#39;California&#39;:&#39;Sacramento&#39;）则被放在了最后。 字典的运算keys、values 和 items 方法均会返回包含相应值的对象。可以使用 list 函数将字典转换成列表。 运算名 运算符 解释 [] myDict[k] 返回与 k 相关联的值，如果没有则报错 in key in adict 如果 key 在字典中，返回 True，否则返回 False del del adict[key] 从字典中删除 key 的键–值对 字典的方法get 方法有两种版本。如果键没有出现在字典中，get 会返回 None。然而，第二个可选参数可以返回特定值。 方法名 用法 解释 keys adict.keys() 返回包含字典中所有键的 dict_keys 对象 values adict.values() 返回包含字典中所有值的 dict_values 对象 items adict.items() 返回包含字典中所有键–值对的 dict_items 对象 get adict.get(k) 返回 k 对应的值，如果没有则返回 None get adict.get(k, alt) 返回 k 对应的值，如果没有则返回 alt 字典实例12345678910111213141516171819&gt;&gt;&gt; phoneext=&#123;&#x27;david&#x27;:1410, &#x27;brad&#x27;:1137&#125;&gt;&gt;&gt; phoneext&#123;&#x27;brad&#x27;:1137, &#x27;david&#x27;:1410&#125;&gt;&gt;&gt; phoneext.keys()dict_keys([&#x27;brad&#x27;, &#x27;david&#x27;])&gt;&gt;&gt; list(phoneext.keys())[&#x27;brad&#x27;, &#x27;david&#x27;]&gt;&gt;&gt; phoneext.values()dict_values([1137, 1410])&gt;&gt;&gt; list(phoneext.values())[1137, 1410]&gt;&gt;&gt; phoneext.items()dict_items([(&#x27;brad&#x27;, 1137), (&#x27;david&#x27;, 1410)])&gt;&gt;&gt; list(phoneext.items())[(&#x27;brad&#x27;, 1137), (&#x27;david&#x27;, 1410)]&gt;&gt;&gt; phoneext.get(&quot;kent&quot;)&gt;&gt;&gt; phoneext.get(&quot;kent&quot;, &quot;NO ENTRY&quot;)&#x27;NO ENTRY&#x27;&gt;&gt;&gt; 输入和输出程序经常要和用户进行交互。 目前的大多数程序使用对话框作为要求用户提供某种输入的方式。尽管 Python 确实有方法来创建这样的对话框，但是可以利用更简单的函数。Python 提供了一个函数，它使得我们可以要求用户输入数据并且返回一个字符串的引用。这个函数就是 input。 提示字符串input 函数接受一个字符串作为参数。由于该字符串包含有用的文本来提示用户输入，因此它经常被称为 提示字符串。举例来说，可以像下面这样调用 input。 不论用户在提示字符串后面输入什么内容，都会被存储在 aName 变量中。使用 input 函数，可以非常简便地写出程序，让用户输入数据，然后再对这些数据进行进一步处理。例如，在下面的两条语句中，第一条要求用户输入姓名，第二条则打印出对输入字符串进行一些简单处理后的结果。 12345aName = input(&quot;Please enter your name &quot;)print(&quot;Your name in all capitals is &quot;, aName.upper(), &quot;and has length&quot;, len(aName)) 需要注意的是，input 函数返回的值是一个字符串，它包含用户在提示字符串后面输入的所有字符。如果需要将这个字符串转换成其他类型，必须明确地提供类型转换。在下面的语句中，用户输入的字符串被转换成了浮点数，以便于后续的算术处理。 123sradius = input(&quot;Please enter the radius of the circle &quot;)radius = float(sradius)diameter = 2 * radius 格式化字符串print 函数为输出 Python 程序的值提供了一种非常简便的方法。它接受零个或者多个参数，并且将单个空格作为默认分隔符来显示结果。通过设置 sep 这一实际参数可以改变分隔符。此外，每一次打印都默认以换行符结尾。这一行为可以通过设置实际参数 end 来更改。下面是一些例子。 12345678&gt;&gt;&gt; print(&quot;Hello&quot;)Hello&gt;&gt;&gt; print(&quot;Hello&quot;,&quot;World&quot;)Hello World&gt;&gt;&gt; print(&quot;Hello&quot;,&quot;World&quot;, sep=&quot;***&quot;)Hello***World&gt;&gt;&gt; print(&quot;Hello&quot;,&quot;World&quot;, end=&quot;***&quot;)Hello World*** Python 提供了另一种叫作 格式化字符串 的方式。格式化字符串是一个模板，其中包含保持不变的单词或空格，以及之后插入的变量的占位符。例如，下面的语句包含 is 和 years old.，但是名字和年龄会根据运行时变量的值而发生改变。 1print(aName, &quot;is&quot;, age, &quot;years old.&quot;) 使用格式化字符串，可以将上面的语句重写成下面的语句。 1print(&quot;%s is %d years old.&quot; % (aName, age)) 格式化字符串可用的类型声明% 是字符串运算符，被称作 格式化运算符。 表达式的左边部分是模板（也叫格式化字符串），右边部分则是一系列用于格式化字符串的值。 格式化字符串可以包含一个或者多个转换声明。转换字符告诉格式化运算符，什么类型的值会被插入到字符串中的相应位置。 在上面的例子中，%s 声明了一个字符串，%d 则声明了一个整数。其他可能的类型声明还包括 i、u、f、e、g、c 和 %。 字符 输出格式 d、i 整数 u 无符号整数 f m.dddd 格式的浮点数 e m.dddde+&#x2F;-xx 格式的浮点数 E m.ddddE+&#x2F;-xx 格式的浮点数 g 对指数小于-4 或者大于 5 的使用 %e，否则使用 %f c 单个字符 s 字符串，或者任意可以通过 str 函数转换成字符串的 Python 数据对象 % 插入一个常量 % 符号 格式化修改符 修改符 例子 解释 数字 %20d 将值放在 20 个字符宽的区域中 - %-20d 将值放在 20 个字符宽的区域中，并且左对齐 + %+20d 将值放在 20 个字符宽的区域中，并且右对齐 0 %020d 将值放在 20 个字符宽的区域中，并在前面补上 0 . %20.2f 将值放在 20 个字符宽的区域中，并且保留小数点后 2 位 (name) %(name)d 从字典中获取 name 键对应的值 1234567891011&gt;&gt;&gt; price = 24&gt;&gt;&gt; item = &quot;banana&quot;&gt;&gt;&gt; print(&quot;The %s costs %d cents&quot; % (item,price))The banana costs 24 cents&gt;&gt;&gt; print(&quot;The %+10s costs %5.2f cents&quot; % (item,price))The banana costs 24.00 cents&gt;&gt;&gt; print(&quot;The %+10s costs %10.2f cents&quot; % (item,price))The banana costs 24.00 cents&gt;&gt;&gt; itemdict = &#123;&quot;item&quot;:&quot;banana&quot;,&quot;cost&quot;:24&#125;&gt;&gt;&gt; print(&quot;The %(item)s costs %(cost)7.1f cents&quot; % itemdict)The banana costs 24.0 cents 控制结构Python提供的标准的标准控制语句有 while 语句以及 for 语句。 1234567891011&gt;&gt;&gt; counter = 1&gt;&gt;&gt; while counter &lt;= 5:... print(&quot;Hello, world&quot;)... counter = counter + 1...Hello, worldHello, worldHello, worldHello, worldHello, world 看下面这个例子。 1while counter &lt;= 10 and not done: 迭代语句只有在上面两个条件都满足的情况下才会被执行。变量 counter 的值需要小于或等于 10，并且变量 done 的值需要为 False（not False 就是 True），因此 True and True 的最后结果才是 True。 for在遍历每一个成员上非常的方便。例如： 12345678&gt;&gt;&gt; for item in [1,3,6,2,5]:... print(item)...13625 列表解析式列表可以通过使用迭代结构和分支结构来创建。这种方式被称为 列表解析式。通过列表解析式，可以根据一些处理和分支标准轻松创建列表。 举例来说，如果想创建一个包含前 10 个完全平方数的列表，可以使用以下的 for 语句。 12345&gt;&gt;&gt; sqlist = []&gt;&gt;&gt; for x in range(1,11): sqlist.append(x*x)&gt;&gt;&gt; sqlist[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 进阶：使用列表解析式，只需一行代码即可创建完成。 123&gt;&gt;&gt; sqlist = [x*x for x in range(1,11)]&gt;&gt;&gt; sqlist[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 进阶：变量 x 会依次取由 for 语句指定的 1 到 10 为值。之后，计算 x*x 的值并将结果添加到正在构建的列表中。列表解析式也允许添加一个分支语句来控制添加到列表中的元素。 123&gt;&gt;&gt; sqlist = [x*x for x in range(1,11) if x%2 != 0]&gt;&gt;&gt; sqlist[1, 9, 25, 49, 81] 例子：（力扣的原题：输出列表中非元音的字母并以大写形式返回） 12&gt;&gt;&gt;[ch.upper() for ch in &#x27;comprehension&#x27; if ch not in &#x27;aeiou&#x27;][&#x27;C&#x27;, &#x27;M&#x27;, &#x27;P&#x27;, &#x27;R&#x27;, &#x27;H&#x27;, &#x27;N&#x27;, &#x27;S&#x27;, &#x27;N&#x27;] 函数下面定义的简单函数会返回传入值的平方。 1234567&gt;&gt;&gt; def square(n):... return n**2...&gt;&gt;&gt; square(3)9&gt;&gt;&gt; square(square(3))81 同样的，我们可以自己定义一个平方根函数 squareroot() 通过牛顿迭代法求解平方根 1234561. def squareroot(n):2. root = n/2 #initial guess will be 1/2 of n3. for k in range(20):4. root = (1/2)*(root + (n / root))5.6. return root 接下来，模拟调用这个函数 1234&gt;&gt;&gt; squareroot(9)3.0&gt;&gt;&gt; squareroot(4563)67.549981495186216 面向对象：定义 类算法分析相关复杂度计算大 O 表示法 如果可以通过观察循环结构和算法的方式快速判断出复杂度就算出师 异序词排序问题 1234567891011121314151617181920212223def anagramSolution1(s1, s2): alist = list(s2) pos1 = 0 StillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(alist) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 += 1 if found: alist[pos2] = None else: stillOK = False pos1 += 1 return stillOK 123456789101112131415161718def anagramSolution2(s1, s2): alist1 = list(s1) alist2 = list(s2) # 这里需要记住，常用的几类排序时间复杂度在 O(n^2) 或 O(nlogn) alist1.sort() alist2.sort() pos = 0 matches = True while pos &lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos += 1 else: matches = False return matches 123456789101112131415161718192021def anagramSolution3(s1, s2): c1 = [0] * n c2 = [0] * n for i in range(len(s1)): pos = ord(s1[i]) - ord(&#x27;a&#x27;) c1[pos] += 1 for i in range(len(s2)): pos = ord(s2[i] - ord(&#x27;a&#x27;)) c2[pos] += 1 j = 0 stillOk = True while j &lt; 26 and stillOK: if c1[j] == c2[j]: j += 1 else: stillOK = False return stillOk 第四个例子是最快的。因为没有循环嵌套，只有O(n)的复杂度。倘若需要考虑关于空间上的需求，那么第四个例子新开了额外的空间用于存储计数器，这种方式就是常说的：空间换时间的方法。","categories":[],"tags":[]},{"title":"第 354 场周赛|个人总结","slug":"第-354-场周赛-个人总结","date":"2023-07-18T07:11:22.000Z","updated":"2023-07-23T14:23:06.683Z","comments":true,"path":"2023/07/18/第-354-场周赛-个人总结/","link":"","permalink":"https://zade23.github.io/2023/07/18/%E7%AC%AC-354-%E5%9C%BA%E5%91%A8%E8%B5%9B-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"第 354 场周赛心路历程日期：2023年7月16日 第一道路题目是简单的模拟，第二题开始花费了非常多的时间，导致后面没什么时间看第三第四题。上周的两场比赛出了三道动态规划，但这场几乎没有，都是思维题目。 题目链接 可以直接从力扣那边复制粘贴过来 特殊元素平方和 数组的最大美丽值 合法分割的最小下标 最长合法子字符串的长度 第一题——特殊元素平方和 题目类型：模拟 按照题意分析正常模拟就好。我使用的for循环的方法，看到别人又用enumerate的方法，也记录一下。 123456789# 我的做法：for循环class Solution: def sumOfSquares(self, nums: List[int]) -&gt; int: n = len(nums) ans = 0 for i in range(1,n + 1): if n % i == 0: ans += nums[i - 1] * nums[i - 1] return ans 12345678910# 参考榜单：enumerate做法class Solution: def sumOfSquares(self, nums: List[int]) -&gt; int: n = len(nums) ans = 0 for k, v in enumerate(nums, 1): # key 是从 1 开始的 if n % k: continue ans += v * v return ans 第二题——数组的最大美丽值 题目类型：子序列，二分法思维转换 12345678class Solution: def maximumBeauty(self, nums: List[int], k: int) -&gt; int: nums.sort() ans = 1 for i, v in enumerate(nums): j = bisect_right(nums, v + 2 * k) ans = max(ans, j - i) return ans 有几个特殊的“点”： 题目要求的子序列并不要求连续，因此怎么方便处理怎么来。这里排序sort()就成一种简化问题的方式。 合理的使用bisect函数，可以帮助不想写二分查找的伙伴偷懒。 最后的区间 j - i 是也是由上面一条二分之后指针的落点决定的。实际上是一个左闭右开区间。 第三题——合法分割的最小下标 题目类型： 同类题目：169多数元素 O(1) 空间找众数 1234567891011121314151617class Solution: def minimumIndex(self, nums: List[int]) -&gt; int: &quot;&quot;&quot; 支配元素 = 众数 众数在python中的简便求法： Counter(nums).most_common(1)[0] 同类题型：169.多数元素 O(1) 空间找众数 &quot;&quot;&quot; n = len(nums) mode, total = Counter(nums).most_common(1)[0] # 通过这一句话就找到了value freq1 = 0 # 用来记录前半段有多少个支配元素 for i, x in enumerate(nums): if x == mode: freq1 += 1 # 指针每扫过一个众数，左侧指针就加一个 if freq1 * 2 &gt; i + 1 and (total - freq1) * 2 &gt; n - i - 1: # 是否满足题目对整数数组的左右要求 return i return -1 用到的技巧： Conuter函数中，灵活运用统计众数的方法most_commont(n)，其中n代表统计最多出现的前n个元组。Counter(nums).most_common(1)[0]即统计众数 大胆尝试暴力算法（有的时候要看一下数据的长度区间） 第四题——最长合法子字符串的长度 题目类型： （待更新） 总结 个人做题感想之类的 一场语法和思路的赛题。思路上还是需要常用正难则反的原则。","categories":[],"tags":[]},{"title":"第 108 场双周赛|个人总结","slug":"第-108-场双周赛-个人总结","date":"2023-07-10T09:03:58.000Z","updated":"2023-07-10T09:26:15.792Z","comments":true,"path":"2023/07/10/第-108-场双周赛-个人总结/","link":"","permalink":"https://zade23.github.io/2023/07/10/%E7%AC%AC-108-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","excerpt":"","text":"题目链接链接：第 108 场双周赛 3 分 - 最长交替子序列 4 分 - 重新放置石块 5 分 - 将字符串分割为最少的美丽子字符串 6 分 - 黑格子的数目","categories":[],"tags":[]},{"title":"完备区间判断下的二分查找万能模板","slug":"完备区间判断下的二分查找万能模板","date":"2023-07-07T06:57:15.000Z","updated":"2023-07-25T08:18:53.359Z","comments":true,"path":"2023/07/07/完备区间判断下的二分查找万能模板/","link":"","permalink":"https://zade23.github.io/2023/07/07/%E5%AE%8C%E5%A4%87%E5%8C%BA%E9%97%B4%E5%88%A4%E6%96%AD%E4%B8%8B%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%87%E8%83%BD%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"场景单调数列&#x2F;数组 一定可以用二分；但如果非单调的情况，也有可能存在能够使用二分的情况 二分模板整数二分C++123456789101112131415161718192021222324252627#include &lt;iostream&gt;// 整数二分的模板bool check(int x) &#123;/*......*/&#125; // 检查x是否满足某种性质/* 目前发现整数二分的所有情况都可以被下面的两个板子涵盖*/// 2.1.1 区间被划分成 [l, mid] 和 [mid + 1， r]int bsearch_1(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l&#125;// 2.1.2 区间被划分成 [l, mid - 1] 和 [mid, r]int bsearch_2(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (chedk(mid)) l = mid; else r = mid - 1; &#125;&#125; Python1234567891011121314151617181920212223242526# 二分查找def check(x): # 判断x是否满足某种性质 if x &gt; 0: return True else: return False# 2.1.1 区间被划分成 [l, mid] 和 [mid + 1， r]def bsearch_2(l, r): while l &lt; r: mid = l + r &gt;&gt; 1 if (check(mid)): r = mid else: l = mid + 1 return l# 2.1.2 区间被划分成 [l, mid - 1] 和 [mid, r]def bsearch_1(l, r): while l &lt; r: mid = l + r + 1 &gt;&gt; 1 if (check(mid)): l = mid else: r = mid - 1 return l 浮点数二分只有C++要考虑，高贵的Python不需要考虑。 1234567891011#include &lt;iostream&gt;double bsearch_3(double l, double r) &#123; const double eps = 1e-6; while (r - l &gt; eps) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zade23.github.io/tags/Algorithm/"}]},{"title":"矩阵变换和空间占用","slug":"矩阵变换和空间占用","date":"2023-07-07T04:29:35.000Z","updated":"2023-07-07T04:29:35.187Z","comments":true,"path":"2023/07/07/矩阵变换和空间占用/","link":"","permalink":"https://zade23.github.io/2023/07/07/%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E5%92%8C%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Python条件判断的优先级","slug":"Python条件判断的优先级","date":"2023-07-06T12:53:13.000Z","updated":"2023-07-06T13:00:54.121Z","comments":true,"path":"2023/07/06/Python条件判断的优先级/","link":"","permalink":"https://zade23.github.io/2023/07/06/Python%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"背景做LeetCode的时候经常能够发现很多基本功不扎实的问题。这一次是在做一道简单题时候忽视的条件判断优先级的问题 题目连接：https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range 代码部分 问题代码12345678910class Solution: def vowelStrings(self, words: List[str], left: int, right: int) -&gt; int: words = words[left : right + 1] n = len(words) print(n) res = 0 for i in range(n): if words[i][0] == &#x27;a&#x27; or words[i][0] == &#x27;e&#x27; or words[i][0] == &#x27;i&#x27; or words[i][0] == &#x27;o&#x27; or words[i][0] == &#x27;u&#x27; and words[i][-1] == &#x27;a&#x27; or words[i][-1] == &#x27;e&#x27; or words[i][-1] == &#x27;i&#x27; or words[i][-1] == &#x27;o&#x27; or words[i][-1] == &#x27;u&#x27;: res += 1 return res 正确代码1234567891011class Solution: def vowelStrings(self, words: List[str], left: int, right: int) -&gt; int: words = words[left : right + 1] n = len(words) print(n) res = 0 for i in range(n): if words[i][0] == &#x27;a&#x27; or words[i][0] == &#x27;e&#x27; or words[i][0] == &#x27;i&#x27; or words[i][0] == &#x27;o&#x27; or words[i][0] == &#x27;u&#x27;: if words[i][-1] == &#x27;a&#x27; or words[i][-1] == &#x27;e&#x27; or words[i][-1] == &#x27;i&#x27; or words[i][-1] == &#x27;o&#x27; or words[i][-1] == &#x27;u&#x27;: res += 1 return res 二者的差别就在如何衔接 or 和 and 之间的关系上。 具体分析分析错误代码的bug： 在第二段错误代码中，条件判断部分存在问题。以下是有问题的代码片段： 12if words[i][0] == &#x27;a&#x27; or words[i][0] == &#x27;e&#x27; or words[i][0] == &#x27;i&#x27; or words[i][0] == &#x27;o&#x27; or words[i][0] == &#x27;u&#x27; and words[i][-1] == &#x27;a&#x27; or words[i][-1] == &#x27;e&#x27; or words[i][-1] == &#x27;i&#x27; or words[i][-1] == &#x27;o&#x27; or words[i][-1] == &#x27;u&#x27;: res += 1 问题出在逻辑运算符的优先级上。在Python中，and 运算符的优先级高于 or 运算符，因此该条件判断实际上被解释为： 12if words[i][0] == &#x27;a&#x27; or words[i][0] == &#x27;e&#x27; or words[i][0] == &#x27;i&#x27; or words[i][0] == &#x27;o&#x27; or (words[i][0] == &#x27;u&#x27; and words[i][-1] == &#x27;a&#x27;) or words[i][-1] == &#x27;e&#x27; or words[i][-1] == &#x27;i&#x27; or words[i][-1] == &#x27;o&#x27; or words[i][-1] == &#x27;u&#x27;: res += 1 由于 or 运算符的短路特性，只要 words[i][0] 的首字母为元音字母之一，整个条件判断就会被认为是True，导致res增加。而第二个部分 words[i][-1] == &#39;a&#39;、words[i][-1] == &#39;e&#39;等都是单独的条件，不会影响整个条件判断的结果。 修正该bug的方法是使用括号明确指定条件的分组，确保逻辑关系正确。以下是修正后的代码： 12if (words[i][0] == &#x27;a&#x27; or words[i][0] == &#x27;e&#x27; or words[i][0] == &#x27;i&#x27; or words[i][0] == &#x27;o&#x27; or words[i][0] == &#x27;u&#x27;) and (words[i][-1] == &#x27;a&#x27; or words[i][-1] == &#x27;e&#x27; or words[i][-1] == &#x27;i&#x27; or words[i][-1] == &#x27;o&#x27; or words[i][-1] == &#x27;u&#x27;): res += 1 这样修改后，条件判断会首先检查首字母是否为元音字母，然后再检查末尾字母是否为元音字母，两个条件都满足时才会增加res的值。","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zade23.github.io/tags/Algorithm/"}]},{"title":"排列公式和组合公式的详细证明","slug":"排列公式和组合公式的详细证明","date":"2023-05-19T07:08:26.000Z","updated":"2023-05-19T09:03:09.086Z","comments":false,"path":"2023/05/19/排列公式和组合公式的详细证明/","link":"","permalink":"https://zade23.github.io/2023/05/19/%E6%8E%92%E5%88%97%E5%85%AC%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E5%85%AC%E5%BC%8F%E7%9A%84%E8%AF%A6%E7%BB%86%E8%AF%81%E6%98%8E/","excerpt":"","text":"写文章的原因：LeetCode上又一次遇到了 公式表达相关参考 【数学排列组合】 P&amp;C 5S 公式证明 【数学 《排列组合 公式推导》 师大（白某烁请查收）】","categories":[{"name":"数学","slug":"数学","permalink":"https://zade23.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://zade23.github.io/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zade23.github.io/tags/Algorithm/"}]},{"title":"your-first-post","slug":"your-first-post","date":"2023-05-16T09:45:58.000Z","updated":"2023-05-19T07:20:14.764Z","comments":false,"path":"2023/05/16/your-first-post/","link":"","permalink":"https://zade23.github.io/2023/05/16/your-first-post/","excerpt":"","text":"","categories":[{"name":"whatever","slug":"whatever","permalink":"https://zade23.github.io/categories/whatever/"}],"tags":[{"name":"test","slug":"test","permalink":"https://zade23.github.io/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-05-16T09:45:58.000Z","updated":"2023-05-19T07:20:20.118Z","comments":false,"path":"2023/05/16/hello-world/","link":"","permalink":"https://zade23.github.io/2023/05/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"whatever","slug":"whatever","permalink":"https://zade23.github.io/categories/whatever/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zade23.github.io/tags/Hexo/"}]}],"categories":[{"name":"数学","slug":"数学","permalink":"https://zade23.github.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"whatever","slug":"whatever","permalink":"https://zade23.github.io/categories/whatever/"}],"tags":[{"name":"工具网站","slug":"工具网站","permalink":"https://zade23.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"},{"name":"经济学小知识","slug":"经济学小知识","permalink":"https://zade23.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zade23.github.io/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://zade23.github.io/tags/LeetCode/"},{"name":"test","slug":"test","permalink":"https://zade23.github.io/tags/test/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zade23.github.io/tags/Hexo/"}]}