<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ANdRoid&#39;s BLOG</title>
  
  <subtitle>MaTRix</subtitle>
  <link href="https://zade23.github.io/atom.xml" rel="self"/>
  
  <link href="https://zade23.github.io/"/>
  <updated>2024-03-21T03:01:16.819Z</updated>
  <id>https://zade23.github.io/</id>
  
  <author>
    <name>Android</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Transformers_FlashBack</title>
    <link href="https://zade23.github.io/2024/03/21/Transformers-FlashBack/"/>
    <id>https://zade23.github.io/2024/03/21/Transformers-FlashBack/</id>
    <published>2024-03-21T02:10:26.000Z</published>
    <updated>2024-03-21T03:01:16.819Z</updated>
    
    
    
    
    <category term="Deeplearning" scheme="https://zade23.github.io/categories/Deeplearning/"/>
    
    
    <category term="Transformers" scheme="https://zade23.github.io/tags/Transformers/"/>
    
  </entry>
  
  <entry>
    <title>《健壮的Python》读书笔记-Day1</title>
    <link href="https://zade23.github.io/2024/03/20/%E3%80%8A%E5%81%A5%E5%A3%AE%E7%9A%84Python%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Day1/"/>
    <id>https://zade23.github.io/2024/03/20/%E3%80%8A%E5%81%A5%E5%A3%AE%E7%9A%84Python%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Day1/</id>
    <published>2024-03-20T13:45:05.000Z</published>
    <updated>2024-03-20T13:45:51.762Z</updated>
    
    
    
    
    <category term="读书笔记" scheme="https://zade23.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LLaMA-Factory原理与底层实现</title>
    <link href="https://zade23.github.io/2024/03/19/LLaMA-Factory%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zade23.github.io/2024/03/19/LLaMA-Factory%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-03-19T02:53:47.000Z</published>
    <updated>2024-03-20T13:30:21.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LLaMA-Factory的简要介绍"><a href="#LLaMA-Factory的简要介绍" class="headerlink" title="LLaMA-Factory的简要介绍"></a>LLaMA-Factory的简要介绍</h2><p>简化大模型训练的工具</p><p>从 Pre-train → SFT（监督微调，supervised fine-tuning）→ RLHF（基于人类反馈的强化学习，reinforcement learning human feedback），一步完成。</p><p>一张4090完成70B参数的模型微调。</p><p>效率：</p><p>算子上提高两倍提速和60%的缓存节省。</p><p>一键完成。</p><p>通过分布式框架，甚至可以实现最多180B的框架模型微调。</p><p>目前已经有数十篇ArXiv论文使用了LLaMA-Factory工具作为微调框架。</p><h2 id="为什么要使用LLaMA-Factory"><a href="#为什么要使用LLaMA-Factory" class="headerlink" title="为什么要使用LLaMA-Factory"></a>为什么要使用LLaMA-Factory</h2><ol><li>如果从头训练一个llama2,模型，从LLaMA论文来看，仅7B参数就需要184320GPU小时，是非常遥不可及的时长。</li><li>报错难追踪，因为训练的报错常常是CUDA层面的bug，非常不方便定位。</li></ol><p>GaLora微调技术，关于一种全参数的高效训练方法</p><p>QLora微调技术，一种Lora训练的量化版本。举例来说，在7B模型下使用2bite的量化微调QLora方法，可以有效的降低到仅仅需要4GB的显存占用。</p><p>Lora是在网络的旁边增加一个旁路，将d维度的高秩表征映射到r维的低秩表征，最后再从r维重新映射回d维。由于完整的微调工作是在缩小后的r维上进行的，这样就使得完整的训练中需要修改的参数量大幅度的降低（只用到0.01%的参数，显存占用量减少3倍）。Lora用多了还是有一个明显的缺陷，即对很多任务的拟合依然不是很好。</p><p>但是GaLora会是更好的微调方法，因为它具备了全参数微调的能力。</p><h2 id="LLaMA-Factory的结构分层"><a href="#LLaMA-Factory的结构分层" class="headerlink" title="LLaMA-Factory的结构分层"></a>LLaMA-Factory的结构分层</h2><p>从最底层开始介绍：</p><p>底层加速层：已适配的硬件有英伟达、华为、海光</p><p>软件层和计算架构层：以PyTorch和Hugging Face 为主。DeepSpeed作为分布式多卡加速训练的方案（使用了一种数据并行的方案，平均分配所有参数到多卡环境中），在工程架构实现以后，未来将支持更多的框架。</p><p>大模型和数据层：更高层的抽象，比如Flash Attention RoPE Scaling，以及数据上的集成，比如动态集成数据</p><p>高效训练层：预训练&#x2F;继续训练 + 监督微调 + PPO算法</p><h2 id="如何优化每一步的加速过程"><a href="#如何优化每一步的加速过程" class="headerlink" title="如何优化每一步的加速过程"></a>如何优化每一步的加速过程</h2><p>简单回顾一下大模型的训练方式，首先是InstructGPT论文，它使用到的训练方法和GPT是一样，称之为<strong>三阶段训练方法</strong>：</p><p>三个阶段可以分为<strong>问答阶段、模型奖励阶段、强化学习训练</strong>：</p><ol><li>问答阶段：利用人类标记好的数据，进行指令的微调工作。在这一阶段，模型就初具了能够<strong>听懂人类指令</strong>和<strong>完成对话</strong>的基本功能。它存在的弊端是，当下的模型依然含有有害内容，而且相对输出的内容过短。</li><li>设计模型奖励阶段：这一步主要任务就是收集数据，构造一个已标注过的文本对比数据集。建立一个奖励模型（RM，reward model），该奖励模型可以对每一个给定的问题和这个问题的答案输出一个标量的分数。</li><li>强化学习：通过这个得到的标量分数，通过PPO算法去微调问答阶段得到的微调模型（偏好对齐）。</li></ol><p>通过以上三步，加上LLaMA-Factory的一些技术，使得这一套训练工作流比原始训练更加高效。</p><h3 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h3><p>在开始将解SFT之前，首先讲解一下预训练。</p><p>预训练是模型训练过程中必要的一个阶段，在有大量无标注的语料情况下，我们希望可以先不进行标注。通过大量的无标注数据的预训练方法，使得模型在我们相关领域的数据上表现的更好(思考为什么？)。</p><p>这里我们使用类似GPT3的<strong>自回归模型（auto-regressive language model）</strong>，根据前i-1个tokens来预测第i个token的能力。</p><p>在持续训练的过程中，使用传统的因果建模的方式，通过计算交叉熵损失的方式来最小化下面这个对数似然的损失来实现模型的优化。<br>$$<br>\mathcal{L}_ {\mathrm{CLM}}&#x3D;-\frac{1}{n} \sum_ {i&#x3D;1}^{n} \log P\left(x_ {i} \mid x_ {1}, x_ {2}, \ldots, x_ {i-1} ; \theta\right)<br>$$<br>它的优势是：通过无监督的方式来完成一系列优化。</p><h2 id="预训练阶段的语料处理"><a href="#预训练阶段的语料处理" class="headerlink" title="预训练阶段的语料处理"></a>预训练阶段的语料处理</h2><p>这里，处理这种预训练阶段的数据最高效的方法有两种，分别是序列打包方法（sequence packing）和数据的流式加载的（data streaming），下面对二者分别进行介绍。</p><h3 id="序列打包方法"><a href="#序列打包方法" class="headerlink" title="序列打包方法"></a>序列打包方法</h3><p>将不同长度的序列打包在一起，省去padding的过程。如图中的过程，左侧的序列是没有打包过的序列，右边序列是打包过的序列。如果我们假设 batch_size &#x3D; 1，则处理左边的序列需要4次；处理右边的序列只需要3次。</p><blockquote><p>问：打包在一起的语料之间有干扰怎么办？</p><p>答：会有干扰，但是影响极小，带来的训练效率提升却是显著的。</p></blockquote><p>通常情况下，默认会使用 sequence packing 的方法处理序列数据。</p><h3 id="数据的流式加载"><a href="#数据的流式加载" class="headerlink" title="数据的流式加载"></a>数据的流式加载</h3><p>下面的这一种数据流式加载技术，主要是为了极大的洁身CPU的内存。通常，我们预期的阶段需要用到几百GB的内存，在使用了数据的流式加载技术后可以节省巨大的内存占用，同时可以避免在分布式训练上造成超时的问题。</p><h2 id="监督微调"><a href="#监督微调" class="headerlink" title="监督微调"></a>监督微调</h2><p>在经历了一系列优化工作后，监督微调（SFT，Supervised Fine-Tuning）通过<strong>问答对</strong>的形式进行一个 sequence to sequence 的学习。</p><p>这一阶段的方法和预训练阶段的损失是一样的，采用交叉熵损失。<br>$$<br>\mathcal{L}_ {\mathrm{SFT}}&#x3D;-\frac{1}{n} \sum_ {i&#x3D;1}^{n} \log P\left(y_{i} \mid x_ {1}, x_ {2}, \ldots, x_ {m} ,y_ {1}, y_ {2}, \ldots, y_ {i-1} ; \theta\right)<br>$$<br>在公式中，x代表问答对中的问题，y代表问答对中的回复。在计算损失的过程中，只计算y上面的损失，对于x一般是不计算损失的。</p><p>在LLaMA-Factory中，主要就是针对这个多轮对话的数据集去优化sft的loss计算方式。</p><p>在多轮对话数据集中，只要计算一次前向传播。</p><p>在模型输出的损失函数计算中，将终止标签<code>eos</code>标注添加到标准输出中，这样可以帮助模型学习到在什么位置进行停止。提高5%到10%的运算效率。</p><h3 id="奖励模型"><a href="#奖励模型" class="headerlink" title="奖励模型"></a>奖励模型</h3><p>奖励模型使用 pairwise ranking loss 来计算损失：<br>$$<br>\mathcal{L}_ {\mathrm{RM}}&#x3D;-\sum_ {(x,y^c,y^r)}\log\left(\sigma(r_ \theta(x,y^c)-r_ \theta(x,y^r))\right)<br>$$<br>其中，yc代表了更好的回复，yr代表了更差的回复，r就是对答案的打分。这个函数希望对好回答的打分高于差回答的打分。</p><p>在训练过程中，会将所有的r1、r2、r3的分数一起作为参考求平均值。</p><p>在推理过程中，只会参考r3的分数最为推理时候的分数。</p><p>思考一个问题：为什么训练的过程中需要将句子中每一个token进行采取然后做分数计算，而不能只计算最后一个token的分数？</p><p>答案是：这样会使得模型过拟合。</p><p>以上是对奖励模型学习过程中的优化过程：针对最后一个输出token进行打分，用于评估奖励模型效果。</p><h2 id="强化学习（PPO学习）"><a href="#强化学习（PPO学习）" class="headerlink" title="强化学习（PPO学习）"></a>强化学习（PPO学习）</h2><p>PPO学习参考一个多臂老虎机问题（bandit problem）。在大模型的过程中，会对一个Prompt产生一条随机的回复，然后奖励这个模型，并对生成的回复进行打分。PPO模型就是为了希望最大化的奖励这个模型给出的分数。</p><p>除了奖励以外，还会对当前这个模型进行<strong>KL惩罚</strong>以防止PPO对模型的过度优化现象。<br>$$<br>\mathcal{J}(\phi)&#x3D;\mathbb{E}_ {(\mathrm{x},\mathrm{y})\sim\mathcal{D}_ {\pi_\phi^{\mathrm{PPO}}}}\left[r_ \theta(x,y)-\beta\log\frac{\pi_\phi^{\mathrm{PPO}}(y|x)}{\pi^{\mathrm{SFT}}(y|x)}\right]<br>$$<br>在上面损失函数中，log后分子上的数学建模是PPO模型，分母上的建模是SFT模型。</p><p>因此，可以看到，如果想要进行PPO模型的训练，就需要加载三个模型。如果只有一张显卡，就很难把三个模型都运行起来。</p><h3 id="模型权重共享的方法"><a href="#模型权重共享的方法" class="headerlink" title="模型权重共享的方法"></a>模型权重共享的方法</h3><p>在三个模型中，参数的大头在backbone部分，这部分的参数和空间占了整个模型空间的98%左右。如果多次读取模型，最冗余的状态就是backbone的重复加载和卸载。</p><p>这里我们引入LoRA适配器的方法，共享backbone部分参数，在训练过程中动态加载LoRA和adapter模块。</p><p>PPO算法拥有一些强化学习的通病，就是难收敛。这里可以推荐一个替代的强化学习算法DPO，公式上的差别较小：<br>$$<br>\mathcal{L}_ {\mathrm{DPO}}&#x3D;-\sum_ {(x,y^c,y^{\prime})\sim\mathcal{D}}\left[\log\sigma\left(\beta\log\frac{\pi^{\mathrm{DPO}}(y^c|x)}{\pi^{\mathrm{SFT}}(y^c|x)}-\beta\log\frac{\pi^{\mathrm{DPO}}(y^r|x)}{\pi^{\mathrm{SFT}}(y^r|x)}\right)\right]<br>$$</p><h3 id="LLaMA-Factory在应用上的优化"><a href="#LLaMA-Factory在应用上的优化" class="headerlink" title="LLaMA-Factory在应用上的优化"></a>LLaMA-Factory在应用上的优化</h3><p>在强化学习的两个算法中，DPO收敛更快，但是更容易过拟合；PPO效果好，但是不容易收敛&#x2F;收敛慢。</p><p>在LLaMA-Factory上提出了混合微调梯度的方法。</p><p>将sft损失乘一个损失因子γ后，将整体值加到DPO中。由于它是一个常数项，所以并不会增加梯度计算的负担</p><h3 id="实现工具调用训练"><a href="#实现工具调用训练" class="headerlink" title="实现工具调用训练"></a>实现工具调用训练</h3><p>使得大模型具有调用外部工具的能力（LangChain）。</p><p>如果咨询大模型：当前时刻某个酒店有多少客房</p><p>如果直接让大模型回答相关问题，大模型既不知道最新的知识，也不清楚没见过的专有名词（酒店的名称）。</p><p>而通过LangChain等方法，就可以将整个工具链上附带工具化调用的能力，其实就是格式化大模型输出的能力。将模型的输出格式，变成可以随着工具进行传参的格式。</p><p>在原有论文的基础上，将传入参数的格式变成json格式传入，这样就可以学习到一些嵌套结构例如列表等多参数的传递。</p><p>工具链的学习过程没有特别多的技巧，就是一个多轮对话的sft学习，重要的是对标准的传递格式的学习。</p><h3 id="使用Flash-Attention加速优化"><a href="#使用Flash-Attention加速优化" class="headerlink" title="使用Flash Attention加速优化"></a>使用Flash Attention加速优化</h3><p>一种计算上无损的加速方式，推理速度提升<strong>2~3</strong>倍，主要在硬件层实现，其原理是提升了I&#x2F;O的执行效率。</p><p>它的替身效率随上下文长度的提升而显著的提升。</p><h3 id="模型量化"><a href="#模型量化" class="headerlink" title="模型量化"></a>模型量化</h3><p>GPTQ的方式可以将模型的权重量化到4bit的程度</p><h3 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h3><p>困惑度是指将模型的输入扩充超过最长tokens的限制，那么模型对于输入几乎会丧失所有的推理能力。</p><p>位置编码可以将长序列的困惑度大幅度降低。</p><p>这里介绍两种插值方法：线性差值（Linear Scaling）和 NTK-aware 差值。</p><h3 id="损失函数的优化"><a href="#损失函数的优化" class="headerlink" title="损失函数的优化"></a>损失函数的优化</h3><p>在LoRA自身的反向传播过程中，PyTorch的反向传播实现得不够好。</p><p>例如，对下面A计算梯度，它是一个m×d维的矩阵，乘m×h维的矩阵，乘h×r维的矩阵。</p><p>在PyTorch中，它会先将大矩阵相乘，然后再去乘小矩阵。</p><p>而如果先将两个较小的矩阵进行相乘，最后再乘较大的矩阵，计算量是大幅度缩小的。（矩阵的乘法交换律）</p><p>那么，通过替换原有的PyTorch中的的梯度计算方法，可以大幅度减少需要计算的浮点运算数量。</p><h3 id="计算稳定性上的优化"><a href="#计算稳定性上的优化" class="headerlink" title="计算稳定性上的优化"></a>计算稳定性上的优化</h3><p>fp16精度下的训练有不稳定的情况，bf16相比前者更加稳定。但是由于精度上的差异，导致二者在训练和运行推理时的兼容性上有一定的问题。</p><ul><li>bf16精度训练的模型，可以运行在fp16精度的环境下</li><li>fp16精度训练的模型，不可以运行在bf16精度的环境下</li></ul><p>如果在LLaMA-Factory的环境上强制运行后者，将会得到一个warning警告。</p><h3 id="更好的工具调用和总结能力"><a href="#更好的工具调用和总结能力" class="headerlink" title="更好的工具调用和总结能力"></a>更好的工具调用和总结能力</h3><p>实例展示了通过相应的数据集在LLaMA-Factory上进行训练后，模型不仅可以正确的理解输入的工具调用指令，还能生成正确对应格式的结果。</p><h3 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h3><p>继续预训练(continue pre-training)相关</p><ul><li>继续预训练最好在base模型上进行（不要用chat版）</li><li>Scaling law 是非常必要的</li><li>参考前人最常用的超参数设置可以事半功倍</li><li>需要竟可能大数量级的tokens去继续训练过程</li><li>多阶段训练可能会提高模型的能力</li><li>词表扩充有可能害了训练结果（除非你需要换小语种）</li></ul><p>监督微调（SFT）相关</p><ul><li>数据质量很重要（合理使用GPT-4去标注知识）</li><li>数据集非常小（只有几百条），最好直接使用chat模型做微调并且保持和数据集模板的对齐</li><li>为了保证微调过程中那个，模型原有的能力不会损失太明显，还是需要再微调的过程中加上一些通用领域的知识。</li><li>Qlora有时币Lora效果更好（更大幅度的降低参数，带来了更稳定的模型）</li><li>（一般植入新知识的过程都在继续预训练的过程中进行）如果一定要在监督微调的过程中植入新知识，那么就需要加入“同意不同文(或不同格式)”的几十条数据。例如：在监督微调部分修改模型的自我认知，就需要几百条数据来完成一项知识的植入。</li><li>超参数没有最好的，只有实践才知道（实践出真知）</li></ul><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><p>问：Flash Attention没法在V100上用，有什么好的办法？</p><p>答：在PyTorch2.0之后，已经实现了替代了FlashAttention的轮子。</p><p>问：超参数设置怎么来？</p><p>答：参考别的论文。</p><p>问：针对不同的response做优化，答案长度不同的情况下，如何做归一化呢？</p><p>答：不同长度的情况下，会使用tokens填充的方法，将较少tokens的向量做padding，最终补齐长度和较长的tokens一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LLaMA-Factory的简要介绍&quot;&gt;&lt;a href=&quot;#LLaMA-Factory的简要介绍&quot; class=&quot;headerlink&quot; title=&quot;LLaMA-Factory的简要介绍&quot;&gt;&lt;/a&gt;LLaMA-Factory的简要介绍&lt;/h2&gt;&lt;p&gt;简化大模型训</summary>
      
    
    
    
    <category term="LLM" scheme="https://zade23.github.io/categories/LLM/"/>
    
    
    <category term="Training" scheme="https://zade23.github.io/tags/Training/"/>
    
  </entry>
  
  <entry>
    <title>Python模块封装导入和包的相关知识</title>
    <link href="https://zade23.github.io/2024/03/13/Python%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E5%AF%BC%E5%85%A5%E5%92%8C%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://zade23.github.io/2024/03/13/Python%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E5%AF%BC%E5%85%A5%E5%92%8C%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</id>
    <published>2024-03-13T06:12:24.000Z</published>
    <updated>2024-03-14T06:29:05.733Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D">背景介绍</a></li><li><a href="#tldr">TL；DR</a></li><li><a href="#%E6%A8%A1%E5%9D%97">模块</a><ul><li><a href="#%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3">快速理解</a></li><li><a href="#%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F">导入方式</a></li><li><a href="#%E4%BB%A5%E8%84%9A%E6%9C%AC%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9D%97">以脚本方式运行模块</a></li><li><a href="#python%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91">Python文件的编译</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0dir%E6%9F%A5%E7%9C%8B%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8D%E7%A7%B0">使用内置函数dir()查看模型定义的名称</a></li></ul></li><li><a href="#%E5%8C%85">包</a><ul><li><a href="#%E4%BB%8E%E5%8C%85%E4%B8%AD%E5%AF%BC%E5%85%A5">从包中导入*</a></li><li><a href="#%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5">相对导入</a></li><li><a href="#%E5%A4%9A%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E5%8C%85">多目录中的包</a></li></ul></li></ul><hr><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>作为非科班的程序员，在代码规范和程序思维上是有欠缺的（仅代表我个人）。</p><p>这些问题会在合作开发项目中暴露出来（阅读其他成员代码以及在其他成员代码上续写功能这类型的任务中暴露的更加明显），比如：对程序模块的封装、底层架构的了解（底层架构对于阅读代码和理解代码很重要）、Python语言的标准库以及装饰器使用等等……</p><p>2024年的主题就是：“还债”。目标是尽快补齐在程序架构和工程领域的能力。</p><h2 id="TL；DR"><a href="#TL；DR" class="headerlink" title="TL；DR"></a>TL；DR</h2><p>在Python工程中，模块是一个包含Python定义和语句的文件，一般以.py作为后缀。模块中的定义可以导入到其他模块或者主程序(main)中，这样做的的目的是方便程序的维护和复用。</p><ul><li>模块的代入：通过<code>import</code>导入模块。模块不会直接把模块自身的函数名称添加到当前命名空间中，而是将模块名称添加到命名空间中。再通过模块名称访问其中的函数，例如：<code>import torch \ torch.nn.functional()</code></li><li>模块的作用：可执行的语句以及函数定义，用于初始化模块。每个模块都有自己的私有命名空间，它会被用作模块中定义的所有函数的全局命名空间。模块可以导入其他模块，被导入的模块名称会被添加到该模块的全局命名空间。（每个模块都有自己的命名空间，防止与用户的全局变量发生冲突）。</li></ul><p>模块功能所做的一切就是为了：<strong>代码的复用和方便维护。</strong></p><p>总览：</p><p><img src="https://raw.githubusercontent.com/usingnamespaceX/picture_bed/main/Python_modules%26package.png" alt="modules&amp;package"></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="快速理解"><a href="#快速理解" class="headerlink" title="快速理解"></a>快速理解</h3><p>现在有个程序模块名称为<code>fibo.py</code>，通过它的名字大致猜测应该是斐波那契数列的功能实现。</p><p>打开这个<code>.py</code>文件，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fibonacci numbers module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):    <span class="comment"># write Fibonacci series up to n</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib2</span>(<span class="params">n</span>):   <span class="comment"># return Fibonacci series up to n</span></span><br><span class="line">    result = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        result.append(a)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>可以看到该模块中有两个方法，分别是：<code>fib</code>和<code>fib2</code>。</p><p>如果我想在该模块中使用这两个函数的功能，可以直接调用函数名称并传入参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">1000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure><p>这时自然而然的诞生一个新的问题，如果在这个函数之外，我依然想使用这两个函数的功能在怎办呢？</p><p>先展示结果，最后再讲解细节。</p><p>现在，新建一个脚本文件(保证该脚本文件和<code>fibo.py</code>在同一目录下)，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib(<span class="number">1000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__name__</span><br><span class="line"><span class="string">&#x27;fibo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib <span class="comment"># 如果想要经常使用某个函数功能，可以把它赋值给局部变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure><p>可以看到，新建的脚本文件中通过<code>import fibo</code>调用了开头写的斐波那契数列功能的模块。</p><p>当想要使用模块中的函数方法，仅需要用导入的模块名称加上”.功能函数名称”，就可以实现功能的调用甚至重新命名变量等操作。</p><h3 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h3><p>使用<code>import</code>导入包的方式现列出4种，例如：</p><ol><li><p>导入模块中的方法名称</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br></pre></td></tr></table></figure></li><li><p>导入模块内定义的所有名称（不包括含<code>_</code>开头的名称，并且<strong>不建议</strong>使用这种方法导入）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure></li><li><p>模块名使用<code>as</code>，直接把<code>as</code>后的名称与导入模块绑定</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo <span class="keyword">as</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib.fib(<span class="number">500</span>)</span><br></pre></td></tr></table></figure></li><li><p>结合<code>from</code>一起使用</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib <span class="keyword">as</span> fibonacci</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibonacci(<span class="number">500</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="以脚本方式运行模块"><a href="#以脚本方式运行模块" class="headerlink" title="以脚本方式运行模块"></a>以脚本方式运行模块</h3><p>通常在命令行执行脚本文件的语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python fibo.py &lt;arguments&gt;</span><br></pre></td></tr></table></figure><p>直接运行<code>.py</code>脚本会在我们看不见的地方默认的执行一个事情，即：**把<code>__name__</code>赋值为<code>&quot;__main__&quot;</code>**。</p><p>也就是把下列代码添加到了模块的末尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    fib(<span class="built_in">int</span>(sys.argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>这样做的含义是，在模块作为”main”文件(脚本)进行执行的时候才会运行。</p><p>举个例子：</p><ol><li><p>当模块作为脚本文件执行时(会执行)：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python fibo.py 50</span><br><span class="line">0 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure></li><li><p>当模块被导入到其它模块或主程序时(不会执行)：</p> <figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import fibo</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure></li></ol><h3 id="Python文件的编译"><a href="#Python文件的编译" class="headerlink" title="Python文件的编译"></a>Python文件的编译</h3><p>这部分在官网文档讲解的非常清晰，参考<a href="https://docs.python.org/zh-cn/3/tutorial/modules.html#compiled-python-files">6.1.3. “已编译的” Python 文件</a></p><p>这里附上“Python模块快速加载”的决策细节流程图：</p><p><img src="https://s21.ax1x.com/2024/03/14/pFcXu5T.png" alt="pyc_flow_chart"></p><h3 id="使用内置函数dir-查看模型定义的名称"><a href="#使用内置函数dir-查看模型定义的名称" class="headerlink" title="使用内置函数dir()查看模型定义的名称"></a>使用内置函数dir()查看模型定义的名称</h3><p><code>dir()</code>用于查找模块定义的名称，返回值为排序之后的字符串列表。</p><p>上实例：</p><ol><li><p><code>dir()</code>含参数时：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(fibo)</span><br><span class="line">[<span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fib2&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(sys)</span><br><span class="line">[<span class="string">&#x27;__breakpointhook__&#x27;</span>, <span class="string">&#x27;__displayhook__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__excepthook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__interactivehook__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__stderr__&#x27;</span>, <span class="string">&#x27;__stdin__&#x27;</span>, <span class="string">&#x27;__stdout__&#x27;</span>, <span class="string">&#x27;__unraisablehook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_clear_type_cache&#x27;</span>, <span class="string">&#x27;_current_frames&#x27;</span>, <span class="string">&#x27;_debugmallocstats&#x27;</span>, <span class="string">&#x27;_framework&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_getframe&#x27;</span>, <span class="string">&#x27;_git&#x27;</span>, <span class="string">&#x27;_home&#x27;</span>, <span class="string">&#x27;_xoptions&#x27;</span>, <span class="string">&#x27;abiflags&#x27;</span>, <span class="string">&#x27;addaudithook&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;api_version&#x27;</span>, <span class="string">&#x27;argv&#x27;</span>, <span class="string">&#x27;audit&#x27;</span>, <span class="string">&#x27;base_exec_prefix&#x27;</span>, <span class="string">&#x27;base_prefix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;breakpointhook&#x27;</span>, <span class="string">&#x27;builtin_module_names&#x27;</span>, <span class="string">&#x27;byteorder&#x27;</span>, <span class="string">&#x27;call_tracing&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callstats&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;displayhook&#x27;</span>, <span class="string">&#x27;dont_write_bytecode&#x27;</span>, <span class="string">&#x27;exc_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;excepthook&#x27;</span>, <span class="string">&#x27;exec_prefix&#x27;</span>, <span class="string">&#x27;executable&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>, <span class="string">&#x27;float_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;float_repr_style&#x27;</span>, <span class="string">&#x27;get_asyncgen_hooks&#x27;</span>, <span class="string">&#x27;get_coroutine_origin_tracking_depth&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getallocatedblocks&#x27;</span>, <span class="string">&#x27;getdefaultencoding&#x27;</span>, <span class="string">&#x27;getdlopenflags&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getfilesystemencodeerrors&#x27;</span>, <span class="string">&#x27;getfilesystemencoding&#x27;</span>, <span class="string">&#x27;getprofile&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getrecursionlimit&#x27;</span>, <span class="string">&#x27;getrefcount&#x27;</span>, <span class="string">&#x27;getsizeof&#x27;</span>, <span class="string">&#x27;getswitchinterval&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;gettrace&#x27;</span>, <span class="string">&#x27;hash_info&#x27;</span>, <span class="string">&#x27;hexversion&#x27;</span>, <span class="string">&#x27;implementation&#x27;</span>, <span class="string">&#x27;int_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;intern&#x27;</span>, <span class="string">&#x27;is_finalizing&#x27;</span>, <span class="string">&#x27;last_traceback&#x27;</span>, <span class="string">&#x27;last_type&#x27;</span>, <span class="string">&#x27;last_value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;maxsize&#x27;</span>, <span class="string">&#x27;maxunicode&#x27;</span>, <span class="string">&#x27;meta_path&#x27;</span>, <span class="string">&#x27;modules&#x27;</span>, <span class="string">&#x27;path&#x27;</span>, <span class="string">&#x27;path_hooks&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;path_importer_cache&#x27;</span>, <span class="string">&#x27;platform&#x27;</span>, <span class="string">&#x27;prefix&#x27;</span>, <span class="string">&#x27;ps1&#x27;</span>, <span class="string">&#x27;ps2&#x27;</span>, <span class="string">&#x27;pycache_prefix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;set_asyncgen_hooks&#x27;</span>, <span class="string">&#x27;set_coroutine_origin_tracking_depth&#x27;</span>, <span class="string">&#x27;setdlopenflags&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;setprofile&#x27;</span>, <span class="string">&#x27;setrecursionlimit&#x27;</span>, <span class="string">&#x27;setswitchinterval&#x27;</span>, <span class="string">&#x27;settrace&#x27;</span>, <span class="string">&#x27;stderr&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;stdin&#x27;</span>, <span class="string">&#x27;stdout&#x27;</span>, <span class="string">&#x27;thread_info&#x27;</span>, <span class="string">&#x27;unraisablehook&#x27;</span>, <span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;version_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;warnoptions&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>dir()</code>不含参数时：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fibo&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是通过使用“<strong>带点号模块名</strong>”来构造 Python 模块命名空间的一种方式。</p><p>例如，模块名 <code>A.B</code> 表示名为 <code>A</code> 的包中名为 <code>B</code> 的子模块。</p><blockquote><p>使用<code>modules.func</code>的这种调用方式还有一个好处，就是避免在不同模块中的功能函数命名冲突。</p><p>例如：在 NumPy 或 Pillow 等多模块包中很多功能函数命名相同，这样使用<code>np.func</code>或<code>Pillow.func</code>就不必担心彼此的<code>func</code>模块名冲突了。</p></blockquote><p>假设要为统一处理声音文件与声音数据设计一个模块集（“包”）。声音文件的格式很多（通常以扩展名来识别，例如：<code>.wav</code>，<code>.aiff</code>，<code>.au</code>），因此，为了不同文件格式之间的转换，需要创建和维护一个不断增长的模块集合。</p><p>为了实现对声音数据的不同处理（例如，混声、添加回声、均衡器功能、创造人工立体声效果），还要编写无穷无尽的模块流。</p><p>下面这个分级文件树展示了这个包的架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                          Top-level package</span><br><span class="line">      __init__.py               Initialize the sound package</span><br><span class="line">      formats/                  Subpackage for file format conversions</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  Subpackage for sound effects</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  Subpackage for filters</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><p>导入包时，Python搜索<code>sys.path</code>里的目录，查找包的子目录。</p><p>需要有<code>__init__.py</code>文件才能让Python将包含改文件的目录当做“包”来处理。这样可以防止重名目录如<code>string</code>在无意中屏蔽后续出现在模块搜索路径中的有效模块。</p><p>最简单的情况就是，<code>__init__.py</code>可以是一个空文件，但是它也可以执行包的初始化代码或设置<code>__all__</code>变量，这将在稍后详细描述。</p><p>一些例子说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载子模块 sound.effects.echo 必须通过全名来引用</span></span><br><span class="line">sound.effects.echo.echofilter(<span class="built_in">input</span>, output, delay)</span><br></pre></td></tr></table></figure><p>另一种导入子模块的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载子模块 echo，并且不必加包前缀</span></span><br><span class="line">echo.echofilter(<span class="built_in">input</span>, output, delay = <span class="number">0.7</span>, atten = <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>还有一种，直接导入所需的函数或变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effect.echo <span class="keyword">import</span> echofilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载子模块 echo，使其函数 echofilter() 直接可用:</span></span><br><span class="line">echofilter(<span class="built_in">input</span>, output, delay = <span class="number">0.7</span>, atten = <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="从包中导入"><a href="#从包中导入" class="headerlink" title="从包中导入*"></a>从包中导入*</h3><p>同理于模块的导入，同样不建议这样做。</p><p>一些需要提及的知识点：如果直接使用<code>*</code>进行导入，一般执行的操作为通过包中的<code>__init__.py</code>代码部分的以下<code>__all__</code>中的模块名列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;surround&quot;</span>, <span class="string">&quot;reverse&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>子模块的命名有可能会受到本地定义名称的影响！</strong></p><p>模块中的模块如果和环境中已存在的模块重名，则会被本地<strong>先</strong>定义过的函数名称遮挡。以<code>reverse</code>函数为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [</span><br><span class="line">    <span class="string">&quot;echo&quot;</span>,      <span class="comment"># refers to the &#x27;echo.py&#x27; file</span></span><br><span class="line">    <span class="string">&quot;surround&quot;</span>,  <span class="comment"># refers to the &#x27;surround.py&#x27; file</span></span><br><span class="line">    <span class="string">&quot;reverse&quot;</span>,   <span class="comment"># !!! refers to the &#x27;reverse&#x27; function now !!!</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">msg: <span class="built_in">str</span></span>):  <span class="comment"># &lt;-- this name shadows the &#x27;reverse.py&#x27; submodule</span></span><br><span class="line">    <span class="keyword">return</span> msg[::-<span class="number">1</span>]    <span class="comment">#     in the case of a &#x27;from sound.effects import *&#x27;</span></span><br></pre></td></tr></table></figure><p>官方文档中，推荐的做法是：<code>frome package import submodule</code>.</p><h3 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h3><p>当包由多个子包构成（如示例中的 <code>sound</code> 包）时，可以使用绝对导入来引用同级包的子模块。</p><p>例如，如果 <code>sound.filters.vocoder</code> 模块需要使用 <code>sound.effects</code> 包中的 <code>echo</code> 模块，它可以使用 <code>from sound.effects import echo</code>。</p><p>你还可以编写相对导入代码，即使用 <code>from module import name</code> 形式的 import 语句。</p><p>这些导入使用<strong>前导点号</strong>来表示相对导入所涉及的当前包和上级包。</p><p>例如对于 <code>surround</code> 模块，可以使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure><p><strong>注意，相对导入基于当前模块名。</strong></p><p>因为主模块名永远是 <code>&quot;__main__&quot;</code> ，所以如果计划将一个模块用作 Python 应用程序的主模块，那么该模块内的导入语句必须始终使用绝对导入。</p><h3 id="多目录中的包"><a href="#多目录中的包" class="headerlink" title="多目录中的包"></a>多目录中的包</h3><p>通过 <a href="https://docs.python.org/zh-cn/3/reference/import.html#path">__path__</a> 可以传入字符串列表，找到所有 <code>__init__.py</code>坐在目录的位置。该功能不常用，知道就好。</p><hr><p>相关参考：</p><ul><li><a href="https://docs.python.org/zh-cn/3/tutorial/modules.html#">6. 模块 — Python 3.12.2 文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tldr&quot;&gt;TL；DR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A8%A1%E5%9D%97&quot;&gt;</summary>
      
    
    
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>合作开发中Git工作流程的细节</title>
    <link href="https://zade23.github.io/2024/03/11/%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91%E4%B8%ADGit%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>https://zade23.github.io/2024/03/11/%E5%90%88%E4%BD%9C%E5%BC%80%E5%8F%91%E4%B8%ADGit%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%9A%84%E7%BB%86%E8%8A%82/</id>
    <published>2024-03-11T08:39:05.000Z</published>
    <updated>2024-03-18T09:13:48.612Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%BB%93%E5%BA%93%E4%B8%AD%E5%90%84%E5%88%86%E6%94%AF%E7%9A%84%E8%81%8C%E8%B4%A3">仓库中各分支的职责</a></li><li><a href="#%E6%B8%85%E6%99%B0%E7%9A%84commit">清晰的Commit</a></li></ul><hr><p>记录开发过程中，提交代码仓库的一些经验总结（持续更新……）</p><h3 id="仓库中各分支的职责"><a href="#仓库中各分支的职责" class="headerlink" title="仓库中各分支的职责"></a>仓库中各分支的职责</h3><ol><li><p><strong>master分支</strong>：master分支是存放发布上线的代码的默认位置。当某个功能经过验证和测试后，将develop分支合并到master分支，并为该版本打上相应的标签（例如x.0.0，表示某个大版本的编号）。master分支应该是稳定且经过充分测试的代码。</p></li><li><p><strong>develop分支</strong>：develop分支是整体开发功能的主要分支。在开发阶段，所有功能的开发工作都应提交到develop分支。在功能开发完成后，通过测试和验证后，将develop分支合并到master分支，使功能正式上线。</p></li></ol><blockquote><p>扩展：</p><ul><li>除了master和develop分支外，还可以存在其他类型的分支，如<strong>feature</strong>分支、<strong>bugfix</strong>分支等。这些分支可以用于并行开发不同的功能或修复bug，并在开发完成后合并到develop分支。</li><li>开发团队通常采用分支策略，例如Git Flow或GitHub Flow，来管理不同分支之间的合并和发布流程，以确保代码质量和版本控制的有效管理。</li><li>主分支（如master或main）通常用于存放稳定的、可发布的代码，而开发分支（如develop）则用于整体功能的开发和集成。</li><li>通过使用不同的分支，可以实现并行开发、合理管理代码版本、隔离功能开发和修复等，从而提高团队的协作效率和代码质量。</li><li>重要的是，分支之间的合并应该经过适当的测试和验证，以确保代码的稳定性和功能的正确性。</li></ul></blockquote><h3 id="清晰的Commit"><a href="#清晰的Commit" class="headerlink" title="清晰的Commit"></a>清晰的Commit</h3><ol><li><strong>使用明确的动词</strong>：在提交信息的开头使用明确的动词来描述你的更改。例如，使用 “添加”、”修复”、”更新”、”重构” 等词语，以便其他人可以快速了解你的更改类型。</li><li><strong>保持简洁</strong>：提交信息应该简洁明了，尽量避免冗长的描述。使用简洁的语句来概括你的更改，并在需要时提供详细信息。</li><li><strong>提供相关上下文</strong>：除了简洁的概述外，确保提交信息提供足够的上下文信息，以便其他人能够理解你的更改原因和意图。如果有相关的问题、需求或讨论，可以引用相关的编号或链接。</li><li><strong>遵循团队或项目规范</strong>：根据你所在的团队或项目的规范，使用统一的提交格式和命名约定。这样可以帮助整个团队保持一致的提交信息风格，便于阅读和管理。</li><li><strong>避免无意义的提交信息</strong>：提交信息应该有实际的意义，避免使用模糊或不相关的描述。确保你的提交信息传达了有用的信息，而不仅仅是表明你进行了一次提交。</li><li><strong>使用标准的提交类型</strong>：参考常见的提交类型（如前面所示），选择最适合你更改类型的提交类型。这有助于其他人快速了解你的更改类型，并且在版本控制工具中进行过滤和分类。</li><li><strong>审查和校对</strong>：在提交之前，花一些时间审查和校对你的提交信息。确保拼写正确、语法清晰，并且信息准确传达你的更改。</li></ol><p>常见的提交格式实例：</p><p>当然，以下是一些常见的提交格式示例：</p><ol><li><p><strong>feat</strong>: 添加新功能或特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat: 添加用户注册功能</span><br></pre></td></tr></table></figure></li><li><p><strong>fix</strong>: 修复 bug</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix: 修复登录页面样式错位的 bug</span><br></pre></td></tr></table></figure></li><li><p><strong>docs</strong>: 更新文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs: 更新用户手册中的安装说明</span><br></pre></td></tr></table></figure></li><li><p><strong>style</strong>: 代码样式、格式调整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style: 格式化整个项目的代码风格</span><br></pre></td></tr></table></figure></li><li><p><strong>refactor</strong>: 重构代码，既不修复 bug 也不添加新功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refactor: 重构用户管理模块的代码结构</span><br></pre></td></tr></table></figure></li><li><p><strong>test</strong>: 添加或修改测试代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test: 添加用户注册页面的单元测试</span><br></pre></td></tr></table></figure></li><li><p><strong>chore</strong>: 构建过程或辅助工具的变动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chore: 更新构建脚本以支持新的依赖库</span><br></pre></td></tr></table></figure></li></ol><p>这一切的目的是为了让团队其他成员明确该提交所做的工作，同时也让自己回顾代码的时候明确自己的工作内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%93%E5%BA%93%E4%B8%AD%E5%90%84%E5%88%86%E6%94%AF%E7%9A%84%E8%81%8C%E8%B4%A3&quot;&gt;仓库中各分支的职责&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B</summary>
      
    
    
    
    <category term="Git Workflow" scheme="https://zade23.github.io/categories/Git-Workflow/"/>
    
    
    <category term="Git" scheme="https://zade23.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>更新GitLab仓库SSH</title>
    <link href="https://zade23.github.io/2024/03/07/%E6%9B%B4%E6%96%B0GitLab%E4%BB%93%E5%BA%93SSH/"/>
    <id>https://zade23.github.io/2024/03/07/%E6%9B%B4%E6%96%B0GitLab%E4%BB%93%E5%BA%93SSH/</id>
    <published>2024-03-07T02:09:37.000Z</published>
    <updated>2024-03-11T08:41:35.516Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">问题分析</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">问题解决</a></li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>早上开工，在拉取代码仓库的时候，发现SSH过期，于是更新一下SSH为永久，并做一个记录。SSH过期命令行显示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote:</span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote:</span><br><span class="line">remote: Your SSH key has expired.</span><br><span class="line">remote:</span><br><span class="line">remote: ========================================================================</span><br><span class="line">remote:</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>直接将问题送给poe，让AI分析解答，根据分析结果一步步处理即可解决。结果如下：</p><p><a href="https://imgse.com/i/pFr02Yn"><img src="https://s21.ax1x.com/2024/03/07/pFr02Yn.png" alt="pFr02Yn.png"></a></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ol><li><p>生成新的SSH密码对。<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>，该命令将生成一个 4096 位的 RSA 密钥对，替换邮箱地址为你GitLab注册邮箱。</p></li><li><p>之后会有两次询问你保存位置和输入密码的选项，点击 Enter 键跳过选项即可。显示结果如下：</p><p> <a href="https://imgse.com/i/pFr0XSx"><img src="https://s21.ax1x.com/2024/03/07/pFr0XSx.png" alt="pFr0XSx.png"></a></p></li><li><p>复制生成的SSH，window使用:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>找到GitLab中的SSH Keys一栏，粘贴，保存：<br> <a href="https://imgse.com/i/pFrBZX8"><img src="https://s21.ax1x.com/2024/03/07/pFrBZX8.png" alt="pFrBZX8.png"></a></p></li><li><p>可以拉取仓库了</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%8B%E7%BB%8D&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90&quot;&gt;问题分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%97%AE</summary>
      
    
    
    
    <category term="Git Workflow" scheme="https://zade23.github.io/categories/Git-Workflow/"/>
    
    
    <category term="Git" scheme="https://zade23.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>conda环境报错解决：invalid choice: &#39;activate&#39; </title>
    <link href="https://zade23.github.io/2023/11/22/conda%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%EF%BC%9Ainvalid-choice-activate/"/>
    <id>https://zade23.github.io/2023/11/22/conda%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%EF%BC%9Ainvalid-choice-activate/</id>
    <published>2023-11-22T08:04:41.000Z</published>
    <updated>2024-03-14T03:02:38.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>新部署的服务器上进行LLM模型的微调工作，在配置Anaconde环境后输入环境启动命令 <code>conda activate</code> ，出现从来没有见过的报错：<code>anaconda conda: error: argument command: invalid choice when trying to update packages</code></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>环境问题，直接Google。最终在 GitHub 里<a href="https://github.com/conda/conda/issues/13022">官方仓库</a>和 <a href="https://stackoverflow.com/questions/53995171/anaconda-conda-error-argument-command-invalid-choice-when-trying-to-update-pa">Stack Overflow</a> 上找到一致的答复：安装Anaconde后没有进行初始化。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ol><li><p>终端运行 <code>conda init zsh</code></p></li><li><p>之后重启 shell&#x2F;Terminal (不重启依然报错)</p></li><li><p>终端运行 <code>conda activate env_name</code> 即可</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;新部署的服务器上进行LLM模型的微调工作，在配置Anaconde环境后输入环境启动命令 &lt;code&gt;conda activate&lt;/code</summary>
      
    
    
    
    <category term="Deeplearning" scheme="https://zade23.github.io/categories/Deeplearning/"/>
    
    
    <category term="conda" scheme="https://zade23.github.io/tags/conda/"/>
    
    <category term="environment" scheme="https://zade23.github.io/tags/environment/"/>
    
  </entry>
  
  <entry>
    <title>玩转Docker学习笔记</title>
    <link href="https://zade23.github.io/2023/11/07/%E7%8E%A9%E8%BD%ACDocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://zade23.github.io/2023/11/07/%E7%8E%A9%E8%BD%ACDocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-11-07T07:30:56.000Z</published>
    <updated>2024-03-11T10:00:59.954Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">镜像相关指令</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">容器相关指令</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">网络相关指令</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4">数据卷相关指令</a></li><li><a href="#docker-compose%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8docker-compose">Docker Compose相关指令（使用<code>docker-compose</code>）</a></li><li><a href="#%E9%80%9A%E8%BF%87-dockerfile-%E6%9E%84%E5%BB%BA-docker-image">通过 DockerFile 构建 Docker Image</a></li></ul><hr><h3 id="镜像相关指令"><a href="#镜像相关指令" class="headerlink" title="镜像相关指令"></a>镜像相关指令</h3><ul><li><code>docker pull &lt;image&gt;</code>：从远程仓库拉取一个镜像或仓库到本地。</li><li><code>docker build -t &lt;tag&gt; .</code>：使用当前目录的Dockerfile构建一个新的镜像。</li><li><code>docker images</code>：列出本地存储的镜像。</li><li><code>docker rmi &lt;image&gt;</code>：删除一个或多个本地的镜像。</li><li><code>docker tag &lt;image&gt; &lt;new_tag&gt;</code>：为镜像添加一个新的标签。</li></ul><h3 id="容器相关指令"><a href="#容器相关指令" class="headerlink" title="容器相关指令"></a>容器相关指令</h3><ul><li><code>docker run &lt;image&gt;</code>：创建一个新的容器并运行一个命令。</li><li><code>docker ps</code>：列出当前运行的容器。</li><li><code>docker ps -a</code>：列出所有容器，包括未运行的。</li><li><code>docker stop &lt;container&gt;</code>：停止一个或多个正在运行的容器。</li><li><code>docker start &lt;container&gt;</code>：启动一个或多个已停止运行的容器。</li><li><code>docker restart &lt;container&gt;</code>：重启容器。</li><li><code>docker rm &lt;container&gt;</code>：删除一个或多个容器。</li><li><code>docker logs &lt;container&gt;</code>：获取容器的日志。</li><li><code>docker exec -it &lt;container&gt; &lt;command&gt;</code>：在运行的容器中执行命令，通常用于进入容器。</li></ul><h3 id="网络相关指令"><a href="#网络相关指令" class="headerlink" title="网络相关指令"></a>网络相关指令</h3><ul><li><code>docker network ls</code>：列出所有网络。</li><li><code>docker network create &lt;options&gt; &lt;network_name&gt;</code>：创建一个新的网络。</li><li><code>docker network rm &lt;network&gt;</code>：删除一个或多个网络。</li><li><code>docker network connect &lt;network&gt; &lt;container&gt;</code>：连接一个容器到一个网络。</li><li><code>docker network disconnect &lt;network&gt; &lt;container&gt;</code>：断开容器与网络的连接。</li></ul><h3 id="数据卷相关指令"><a href="#数据卷相关指令" class="headerlink" title="数据卷相关指令"></a>数据卷相关指令</h3><ul><li><code>docker volume create &lt;name&gt;</code>：创建一个新的卷。</li><li><code>docker volume ls</code>：列出所有卷。</li><li><code>docker volume rm &lt;volume&gt;</code>：删除一个或多个卷。</li><li><code>docker volume inspect &lt;volume&gt;</code>：显示详细的卷信息。</li></ul><h3 id="Docker-Compose相关指令（使用docker-compose）"><a href="#Docker-Compose相关指令（使用docker-compose）" class="headerlink" title="Docker Compose相关指令（使用docker-compose）"></a>Docker Compose相关指令（使用<code>docker-compose</code>）</h3><ul><li><code>docker-compose up</code>：在后台启动并运行整个应用。</li><li><code>docker-compose down</code>：停止并移除容器，网络，图像和挂载卷。</li><li><code>docker-compose build</code>：构建或重建服务关联的镜像。</li><li><code>docker-compose logs</code>：查看服务的日志输出。</li></ul><p>这些命令代表了Docker操作的基础，但是实际使用中可能还会遇到更复杂的场景和高级特性。建议通过官方文档或其他学习资源深入理解每个命令的用法和选项。</p><h3 id="通过-DockerFile-构建-Docker-Image"><a href="#通过-DockerFile-构建-Docker-Image" class="headerlink" title="通过 DockerFile 构建 Docker Image"></a>通过 DockerFile 构建 Docker Image</h3><p>一个 Image 是通过一个 DockerFile 定义的，然后使用 docker build 命令构建它。</p><p>DockerFile 中的每一条命令的执行结果都会成为 Image 中的一个 Layer。</p><p>这里，我们通过 Build 一个镜像，来观察 Image 的分层机制：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的Python运行时环境作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录为容器内的/app。如果目录不存在，Docker会自动为你创建这个目录。</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（Dockerfile所在目录）的内容复制到容器内的/app目录中。</span></span><br><span class="line"><span class="comment"># 这意味着你的应用代码和依赖文件（比如requirements.txt）都会被复制进去。</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用RUN命令执行pip安装命令来安装requirements.txt中列出的所有依赖。</span></span><br><span class="line"><span class="comment"># 这里使用了--trusted-host选项来指定可信的PyPI主机，避免SSL证书验证问题。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --trusted-host pypi.python.org -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用EXPOSE指令来告诉Docker容器内的应用将会在80端口上监听连接。</span></span><br><span class="line"><span class="comment"># 需要注意的是，EXPOSE指令本身不会使容器的端口对外界开放，</span></span><br><span class="line"><span class="comment"># 它更多的是一种文档化的作用，真正的端口映射需要在运行容器时通过docker run的-p选项来指定。</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ENV指令设置一个环境变量。这里定义了一个名为NAME的环境变量，值为World。</span></span><br><span class="line"><span class="comment"># 环境变量可以在容器运行时被应用程序读取，用于配置应用行为。</span></span><br><span class="line"><span class="keyword">ENV</span> NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用CMD指令指定容器启动时运行的命令。</span></span><br><span class="line"><span class="comment"># 这里的命令是“python app.py”，即使用Python解释器来运行app.py脚本。</span></span><br><span class="line"><span class="comment"># CMD的主要作用是指定容器的默认执行命令。如果在docker run命令后面指定了其他命令，CMD指定的命令将被覆盖。</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>这份<code>Dockerfile</code>基本上覆盖了构建一个简单Python应用的Docker镜像所需的所有步骤。从选择基础镜像开始，设置工作目录，复制应用代码，安装依赖，到最后指定运行时的命令和暴露的端口，每一步都为镜像的构建提供了必要的指令和配置。</p><p>最终的构建结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@rds-k8s-18-svr0:~/xuran/exampleimage# docker build -t hello ./</span><br><span class="line">Sending build context to Docker daemon  5.12 kB</span><br><span class="line">Step 1/7 : FROM python:2.7-slim</span><br><span class="line"> ---&gt; 804b0a01ea83</span><br><span class="line">Step 2/7 : WORKDIR /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 6d93c5b91703</span><br><span class="line">Step 3/7 : COPY . /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; feddc82d321b</span><br><span class="line">Step 4/7 : RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 94695df5e14d</span><br><span class="line">Step 5/7 : EXPOSE 81</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 43c392d51dff</span><br><span class="line">Step 6/7 : ENV NAME World</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 78c9a60237c8</span><br><span class="line">Step 7/7 : CMD python app.py</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; a5ccd4e1b15d</span><br><span class="line">Successfully built a5ccd4e1b15d</span><br></pre></td></tr></table></figure><p>下面是对这些信息每一步的详细解释：</p><ul><li><p><strong>Sending build context to Docker daemon 5.12 kB</strong><br>这一行表示Docker客户端正在将构建上下文发送给Docker守护进程。构建上下文是指Dockerfile所在目录的内容，Docker会将这些内容打包发送给守护进程。这里的大小是5.12kB，表示你的应用代码和依赖文件等总共大小。</p></li><li><p><strong>Step 1&#x2F;7 : FROM python:2.7-slim</strong><br>这是Dockerfile中的第一步，它基于<code>python:2.7-slim</code>这个镜像来构建新的镜像。<code>---&gt; 804b0a01ea83</code>是基础镜像的ID。</p></li><li><p><strong>Step 2&#x2F;7 : WORKDIR &#x2F;app</strong><br>设置工作目录为<code>/app</code>。如果不存在，Docker会自动创建这个目录。<code>---&gt; Using cache ---&gt; 6d93c5b91703</code>表示这一步使用了缓存，<code>6d93c5b91703</code>是这一层的ID。</p></li><li><p><strong>Step 3&#x2F;7 : COPY . &#x2F;app</strong><br>将构建上下文（Dockerfile所在的目录）的内容复制到容器内的<code>/app</code>目录。<code>---&gt; Using cache ---&gt; feddc82d321b</code>表明这一步也使用了缓存。</p></li><li><p><strong>Step 4&#x2F;7 : RUN pip install –trusted-host pypi.python.org -r requirements.txt</strong><br>在容器内执行<code>pip install</code>命令，安装<code>requirements.txt</code>文件中列出的Python依赖包。<code>---&gt; Using cache ---&gt; 94695df5e14d</code>说明这一步同样使用了缓存。</p></li><li><p><strong>Step 5&#x2F;7 : EXPOSE 81</strong><br>通知Docker容器在运行时将会监听81端口。注意这里与前面提到的Dockerfile中的<code>EXPOSE 80</code>不同，可能是因为Dockerfile被修改了但构建输出没有更新。<code>---&gt; Using cache ---&gt; 43c392d51dff</code>表示使用了缓存。</p></li><li><p><strong>Step 6&#x2F;7 : ENV NAME World</strong><br>设置环境变量<code>NAME</code>的值为<code>World</code>。这个环境变量可以在容器运行时被应用程序使用。<code>---&gt; Using cache ---&gt; 78c9a60237c8</code>也显示这一步使用了缓存。</p></li><li><p><strong>Step 7&#x2F;7 : CMD [“python”, “app.py”]</strong><br>指定容器启动时默认执行的命令。这里是运行<code>app.py</code>脚本。<code>---&gt; Using cache ---&gt; a5ccd4e1b15d</code>意味着这一步也利用了之前的构建缓存。</p></li><li><p><strong>Successfully built a5ccd4e1b15d</strong><br>最后，显示了成功构建的镜像ID为<code>a5ccd4e1b15d</code>。</p></li></ul><p>在这个过程中，<code>Using cache</code>表明Docker发现之前的构建步骤与当前的完全一致，因此它复用了之前的结果来加快构建过程。如果你想要强制Docker重新执行每个步骤而不使用缓存，可以在构建时添加<code>--no-cache</code>选项。</p><hr><p>参考链接：</p><ul><li><a href="https://www.docker.com/101-tutorial/">Docker 101 Tutorial</a></li><li><a href="http://t.csdnimg.cn/cApYV">Docker原理（图解+秒懂+史上最全）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4&quot;&gt;镜像相关指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://zade23.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>pytorch-tutorial-official</title>
    <link href="https://zade23.github.io/2023/10/31/pytorch-tutorial-official/"/>
    <id>https://zade23.github.io/2023/10/31/pytorch-tutorial-official/</id>
    <published>2023-10-31T08:49:36.000Z</published>
    <updated>2024-03-14T03:02:15.673Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#pytorch-%E5%9F%BA%E7%A1%80">Pytorch 基础</a><ul><li><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">快速入门</a><ul><li><a href="#%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE">处理数据</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B">构建模型</a><ul><li><a href="#%E5%9C%A8-pytorch-%E4%B8%AD%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">在 PyTorch 中构建神经网络</a><ul><li><a href="#%E6%A8%A1%E5%9E%8B%E5%B1%82-model-layers">模型层 Model Layers</a></li><li><a href="#nnflatten">nn.Flatten</a></li><li><a href="#nnlinear">nn.Linear</a></li><li><a href="#nnrelu">nn.ReLU</a></li><li><a href="#nnsequential">nn.Sequential</a></li><li><a href="#nnsoftmax">nn.Softmax</a></li><li><a href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0">模型的参数</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%BC%A0%E9%87%8F-tensor">张量 Tensor</a><ul><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%A0%E9%87%8F">初始化张量</a><ul><li><a href="#%E7%9B%B4%E6%8E%A5%E6%9D%A5%E8%87%AA%E6%95%B0%E6%8D%AE">直接来自数据</a></li><li><a href="#%E6%9D%A5%E8%87%AA%E5%8F%A6%E4%B8%80%E4%B8%AA-tensor">来自另一个 Tensor</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E5%80%BC%E6%88%96%E5%B8%B8%E9%87%8F">使用随机值或常量</a></li></ul></li><li><a href="#%E5%BC%A0%E9%87%8F%E7%9A%84%E5%B1%9E%E6%80%A7">张量的属性</a></li><li><a href="#%E5%BC%A0%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C">张量的操作</a><ul><li><a href="#%E7%B1%BB%E4%BC%BC-numpy-%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C">类似 NumPy 的索引和切片操作</a></li><li><a href="#tensor-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5">Tensor 之间的连接</a></li><li><a href="#%E5%BC%A0%E9%87%8F%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97">张量的算术运算</a></li><li><a href="#%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%E5%BC%A0%E9%87%8F">单一元素张量</a></li><li><a href="#%E5%8E%9F%E5%9C%B0%E6%93%8D%E4%BD%9C%E4%B8%8D%E9%80%9A%E8%BF%87%E8%BF%94%E5%9B%9E%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9">原地操作(不通过返回的方式进行原地修改)</a></li></ul></li><li><a href="#tensor-%E5%92%8C-numpy-%E4%BA%8C%E8%80%85%E8%BD%AC%E6%8D%A2">Tensor 和 Numpy 二者转换</a><ul><li><a href="#tensor2numpy_array">Tensor2NumPy_array</a></li><li><a href="#numpy_array2tensor">NumPy_array2Tensor</a></li></ul></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C">数据集的相关操作</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD">数据加载</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%AD%E4%BB%A3%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96">数据集迭代和数据可视化</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86">创建自定义的数据集</a><ul><li><a href="#_init_">_<em>init</em>_</a></li><li><a href="#_len_">_<em>len</em>_</a></li><li><a href="#_getitem_">_<em>getitem</em>_</a></li></ul></li><li><a href="#%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BD%BF%E7%94%A8-dataloader-%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83">准备数据并使用 DataLoader 进行训练</a></li><li><a href="#%E9%81%8D%E5%8E%86-dataloader">遍历 DataLoader</a></li></ul></li><li><a href="#%E8%BD%AC%E6%8D%A2">转换</a><ul><li><a href="#totensor">ToTensor()</a></li><li><a href="#lambda-%E8%BD%AC%E6%8D%A2">Lambda 转换</a></li></ul></li><li><a href="#%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86torchautograd">（核心内容）自动微分(<code>TORCH.AUTOGRAD</code>)</a><ul><li><a href="#%E5%BC%A0%E9%87%8F%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%9B%BE">张量、函数、计算图</a></li><li><a href="#%E6%A2%AF%E5%BA%A6%E8%AE%A1%E7%AE%97">梯度计算</a></li><li><a href="#%E7%A6%81%E7%94%A8%E6%A2%AF%E5%BA%A6%E8%BF%BD%E8%B8%AA">禁用梯度追踪</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E5%9B%BE%E9%83%A8%E5%88%86%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">计算图部分扩展阅读</a></li><li><a href="#%E5%8F%AF%E9%80%89%E9%98%85%E8%AF%BB%E5%BC%A0%E9%87%8F%E6%A2%AF%E5%BA%A6-%E5%92%8C-%E9%9B%85%E9%98%81%E6%AF%94%E7%A7%AFjacobian_products">可选阅读：张量梯度 和 雅阁比积(Jacobian_Products)</a></li></ul></li><li><a href="#%E9%87%8D%E8%A6%81%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0">（重要）优化模型参数</a><ul><li><a href="#%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81">先决条件代码</a></li><li><a href="#%E8%B6%85%E5%8F%82%E6%95%B0">超参数</a></li><li><a href="#%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF">优化循环</a></li><li><a href="#%E5%85%A8%E8%BF%87%E7%A8%8B%E6%95%B0%E6%8D%AE%E8%B7%9F%E8%B8%AA">全过程数据跟踪</a></li></ul></li><li><a href="#%E4%BF%9D%E5%AD%98%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9E%8B">保存、加载和使用模型</a><ul><li><a href="#%E4%BF%9D%E5%AD%98%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%9D%83%E9%87%8D">保存&#x2F;加载模型权重</a></li><li><a href="#%E9%80%9A%E8%BF%87%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BD%A2%E7%8A%B6%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E4%BF%9D%E5%AD%98%E5%8A%A0%E8%BD%BD">通过模型的形状参数进行保存&#x2F;加载</a></li></ul></li><li><a href="#%E5%9C%A8-pytorch-%E4%B8%AD%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%B8%B8%E8%A7%84-checkpoint">在 PyTorch 中保存和加载常规 Checkpoint</a><ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#%E8%AE%BE%E7%BD%AE">设置</a></li><li><a href="#%E6%AD%A5%E9%AA%A4">步骤</a><ul><li><a href="#1%E5%AF%BC%E5%85%A5%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%BA%93">1.导入加载数据所需要的库</a></li><li><a href="#2%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">2.定义和初始化神经网络</a></li><li><a href="#3%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BC%98%E5%8C%96%E5%99%A8">3.初始化优化器</a></li><li><a href="#4%E4%BF%9D%E5%AD%98%E5%B8%B8%E8%A7%84%E6%A3%80%E6%9F%A5%E7%82%B9">4.保存常规检查点</a></li><li><a href="#5%E5%8A%A0%E8%BD%BD%E5%B8%B8%E8%A7%84%E6%A3%80%E6%9F%A5%E7%82%B9">5.加载常规检查点</a></li></ul></li></ul></li><li><a href="#%E4%BB%8E-checkpoint-%E4%B8%AD%E5%8A%A0%E8%BD%BD-nnmodule-%E7%9A%84%E6%8A%80%E5%B7%A7">从 Checkpoint 中加载 <code>nn.Module</code> 的技巧</a><ul><li><a href="#%E6%B4%BB%E7%94%A8-torchloadmmap--true">活用 <code>torch.load(mmap = True)</code></a></li><li><a href="#%E6%B4%BB%E7%94%A8-torchdevicemeta">活用 <code>torch.device(&quot;meta&quot;)</code></a></li><li><a href="#%E6%B4%BB%E7%94%A8-load_state_dictassign--true">活用 <code>load_state_dict(assign = True)</code></a></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li></ul></li></ul></li></ul><h1 id="Pytorch-基础"><a href="#Pytorch-基础" class="headerlink" title="Pytorch 基础"></a>Pytorch 基础</h1><blockquote><p><a href="https://pytorch.org/tutorials/beginner/basics/intro.html">https://pytorch.org/tutorials/beginner/basics/intro.html</a></p></blockquote><p>大多数机器学习工作流：</p><ul><li>处理数据</li><li>创建模型</li><li>优化模型参数</li><li>保存训练后模型</li></ul><p>通过 Pytorch 基础部分的内容，读者可以完整的走完一整个MachineLearning的工作流，若读者对其中某个环节不理解或感兴趣，针对这些工作流中的每一个环节都有相关的扩展阅读链接。</p><p>我们将使用 FashionMNIST 数据集训练一个神经网络，该神经网络预测输入图像是否属于一下类别之一：T恤&#x2F;上衣、裤子、套头衫、连衣裙、外套、凉鞋、成山、运动鞋、包包、靴子。（是个多分类任务）</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><blockquote><p><a href="https://pytorch.org/tutorials/beginner/basics/quickstart_tutorial.html">https://pytorch.org/tutorials/beginner/basics/quickstart_tutorial.html</a></p></blockquote><p>本节会快速走完一个机器学习多分类的Demo，以此快速了解流程中必要的基本ML相关API。</p><h3 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h3><p>Pytorch 中有两个用于处理数据的子库 <code>torch.utils.data.DataLoader</code> 和 <code>torch.utils.data.Dataset.Dataset</code>。顾名思义，<code>Dataset</code> 存储样本及其相应的标签，并将 <code>DataLoader</code> 可迭代对象包装在 <code>Dataset</code> 中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvison.transforms <span class="keyword">import</span> ToTensor</span><br></pre></td></tr></table></figure><p>通过上面的引用(import)，我们可以发现：Pytorch 中有非常多的子库，这些子库专注于某一特定的领域，例如： <a href="https://pytorch.org/text/stable/index.html">TorchText</a>, <a href="https://pytorch.org/vision/stable/index.html">TorchVision</a>, 和 <a href="https://pytorch.org/audio/stable/index.html">TorchAudio</a>, 这些所有子库中都包含相应的数据集。</p><p>本次教程中我们使用 <code>TorchVision</code> 数据集。</p><p>该 <code>torchvision,.datasets</code> 模块包含 <code>Dataset</code> 来自现实世界中的视觉图像数据，最经典的有：CIFAT，COCO(<a href="https://pytorch.org/vision/stable/datasets.html">full list here</a>)</p><p>本次教程中我们使用 <code>FashionMNIST</code> 数据集。每个 <code>TorchVison</code> 下的 <code>Dataset</code> 都包含两个参数：<code>transform</code> 和 <code>target_transform</code> 分别用来<strong>修改样本</strong>与<strong>打标签</strong>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从公开数据集中读取训练数据</span></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root = <span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train = <span class="literal">True</span>,</span><br><span class="line">    download = <span class="literal">True</span>,</span><br><span class="line">    transform = ToTensor(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从公开数据集中读取测试数据</span></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root = <span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train = <span class="literal">False</span>,</span><br><span class="line">    download = <span class="literal">True</span>,</span><br><span class="line">    transform = Totensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下图是在 colab 中运行上面程序块的输出结果：<br><a href="https://imgse.com/i/pin7WJf"><img src="https://z1.ax1x.com/2023/11/01/pin7WJf.md.jpg" alt="pin7WJf.md.jpg"></a></p><p>至此为止，通过上面的工作，我们将 <code>Dataset</code> 作为参数传递给了 <code>DataLoader</code> 。同时封装了相关数据集作为一个可迭代的对象，支持自动批处理、采样、洗牌(shuffling)、和多进程的数据加载。</p><hr><p>下一步中，我们定义 <code>batch_size = 64</code> ，即 <code>dataloader</code> 可迭代中的每个元素都将返回一批含有64个特征的标签。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据读取工具</span></span><br><span class="line">train_dataloader = DataLoader(tarain_data, batch_size = batch_size)</span><br><span class="line">test_dataloader = DataLoader(tast_data, batch_size = batch_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of X [N, C, H, W]: <span class="subst">&#123;X.shape&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of y []: <span class="subst">&#123;y.shape&#125;</span> <span class="subst">&#123;y.dtpye&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape of X [N, C, H, W]: torch.Size([64, 1, 28, 28])</span><br><span class="line">Shape of y: torch.Size([64]) torch.int64</span><br></pre></td></tr></table></figure><blockquote><p>关于 <a href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html">loading data in PyTorch</a> 的详细说明</p></blockquote><hr><h3 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h3><p>为了在 Pytorch 中定义神经网络，我们创建一个继承自  <a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html">nn.Module</a> 的类。</p><p>我们通过 <code>__init__</code> 函数定义神经网络的层，并指明数据如何通过 <code>forward</code> 函数进入神经网络层。</p><blockquote><p>在设备允许的情况下，推荐使用GPU来加速神经网络的运算操作。</p></blockquote><p>代码实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用于训练的设备（cpu/gpu/mps）</span></span><br><span class="line">device = (</span><br><span class="line">    <span class="string">&quot;cuda&quot;</span></span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available()</span><br><span class="line">    <span class="keyword">else</span> <span class="string">&quot;mps&quot;</span></span><br><span class="line">    <span class="keyword">if</span> torch.backends.mps.is_available()</span><br><span class="line">    <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Using <span class="subst">&#123;device&#125;</span> device&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义神经网络的模型结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear_relu_stack = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        logits = self.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = NeuralNetwork().to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Using cpu device</span><br><span class="line">NeuralNetwork(</span><br><span class="line">  (flatten): Flatten(start_dim=1, end_dim=-1)</span><br><span class="line">  (linear_relu_stack): Sequential(</span><br><span class="line">    (0): Linear(in_features=784, out_features=512, bias=True)</span><br><span class="line">    (1): ReLU()</span><br><span class="line">    (2): Linear(in_features=512, out_features=512, bias=True)</span><br><span class="line">    (3): ReLU()</span><br><span class="line">    (4): Linear(in_features=512, out_features=10, bias=True)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="在-PyTorch-中构建神经网络"><a href="#在-PyTorch-中构建神经网络" class="headerlink" title="在 PyTorch 中构建神经网络"></a>在 PyTorch 中构建神经网络</h4><blockquote><p>这一部分是对‘构建模型’部分的一点补充说明，也是 PyTorch 官网教程中的扩展阅读部分</p></blockquote><p>神经网络是由多个对数据进行操作的层&#x2F;模型组合而成的。<a href="https://pytorch.org/docs/stable/nn.html">torch.nn</a>  命名空间几乎已经提供了构建一个神经网络所需要用到的<strong>所有模块</strong>。</p><p>所有模块都在 PyTorch 下的子块  <a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html">nn.Module</a> 中提供。</p><p>基于这样的结构化嵌套模块，整个神经网络可以自由的进行构建和管理复杂的架构。</p><p>在上面的代码块中，我们通过 <code>NeuralNetwork</code> 函数定义了一个神经网络模型 <code>model</code>。</p><p>为了使用该模型，我们将输入数据传递给它。这个操作将执行 <code>forward</code> 操作和一些<a href="https://github.com/pytorch/pytorch/blob/270111b7b611d174967ed204776985cefca9c144/torch/nn/modules/module.py#L866">后台操作</a>。</p><p>请记住：不要直接使用 <code>model.forward()</code> !</p><hr><p>通过输入操作调用模型，最后将返回一个二维张量，其中 dim &#x3D; 0 对应于每个类别的 10 个原始预测输出，dim &#x3D; 1 对应与每个输出的单个值。</p><p>我们可以通过 <code>nn.Softmax</code> 模块实例传递对结果预测的概率来进行最终预测概率的判断。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, device = device)</span><br><span class="line">logits = model(X)</span><br><span class="line">pred_probab = nn.Softmax(dim = <span class="number">1</span>)(logits)</span><br><span class="line">y_pred = pred_probab.argmax(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Predicted class: <span class="subst">&#123;y_pred&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicted class: tensor([7], device = &#x27;cuda:0&#x27;)</span><br></pre></td></tr></table></figure><h5 id="模型层-Model-Layers"><a href="#模型层-Model-Layers" class="headerlink" title="模型层 Model Layers"></a>模型层 Model Layers</h5><p>分解 <code>FashionMNIST</code> 模型中的各层。为了说明这一点，我们通过获取一个包含 3 张大小为 28*28 的小批量图像样本，看看当数据传递到网络时会发生什么。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_image = torch.rand(<span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"><span class="built_in">print</span>(input_image.size())</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([3, 28, 28])</span><br></pre></td></tr></table></figure><h5 id="nn-Flatten"><a href="#nn-Flatten" class="headerlink" title="nn.Flatten"></a>nn.Flatten</h5><p>初始化 <a href="https://pytorch.org/docs/stable/generated/torch.nn.Flatten.html">nn.Flatten</a> 层，将每个2D 28*28 图像转换成包含 784 个像素值的连续数组（保持小批量尺寸(dim &#x3D; 0)）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flatten = nn.Flatten()</span><br><span class="line">flat_image = flatten(input_image)</span><br><span class="line"><span class="built_in">print</span>(flat_image.size())</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([3, 784])</span><br></pre></td></tr></table></figure><h5 id="nn-Linear"><a href="#nn-Linear" class="headerlink" title="nn.Linear"></a>nn.Linear</h5><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.Linear.html">线性层模块</a>通过输入的权重w和偏差值b进行线性变换。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layer1 = nn.Linear(in_features = <span class="number">28</span>*<span class="number">28</span>, out_features = <span class="number">20</span>)</span><br><span class="line">hidden1 = layer1(flat_image)</span><br><span class="line"><span class="built_in">print</span>(hidden1.size())</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([3, 20])</span><br></pre></td></tr></table></figure><h5 id="nn-ReLU"><a href="#nn-ReLU" class="headerlink" title="nn.ReLU"></a>nn.ReLU</h5><p>非线性激活函数可以在模型的输入输出之间创建复杂的映射关系。激活函数通过引入非线性的变换帮助神经网络学习各种现象。</p><p>在实例模型中，我们在线性层之间使用ReLU激活函数。但还有其他激活函数可以在模型的线性层中间作为激活函数使用，详情参考：<a href="https://zh.wikipedia.org/zh-cn/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0">激活函数-wiki</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Before ReLU: <span class="subst">&#123;hidden1&#125;</span>\n\n&quot;</span>)</span><br><span class="line">hidden1 = nn.ReLU()(hidden1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Aftr RelU: <span class="subst">&#123;hidden1&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Before ReLU: tensor([[ 0.4158, -0.0130, -0.1144,  0.3960,  0.1476, -0.0690, -0.0269,  0.2690,</span><br><span class="line">          0.1353,  0.1975,  0.4484,  0.0753,  0.4455,  0.5321, -0.1692,  0.4504,</span><br><span class="line">          0.2476, -0.1787, -0.2754,  0.2462],</span><br><span class="line">        [ 0.2326,  0.0623, -0.2984,  0.2878,  0.2767, -0.5434, -0.5051,  0.4339,</span><br><span class="line">          0.0302,  0.1634,  0.5649, -0.0055,  0.2025,  0.4473, -0.2333,  0.6611,</span><br><span class="line">          0.1883, -0.1250,  0.0820,  0.2778],</span><br><span class="line">        [ 0.3325,  0.2654,  0.1091,  0.0651,  0.3425, -0.3880, -0.0152,  0.2298,</span><br><span class="line">          0.3872,  0.0342,  0.8503,  0.0937,  0.1796,  0.5007, -0.1897,  0.4030,</span><br><span class="line">          0.1189, -0.3237,  0.2048,  0.4343]], grad_fn=&lt;AddmmBackward0&gt;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">After ReLU: tensor([[0.4158, 0.0000, 0.0000, 0.3960, 0.1476, 0.0000, 0.0000, 0.2690, 0.1353,</span><br><span class="line">         0.1975, 0.4484, 0.0753, 0.4455, 0.5321, 0.0000, 0.4504, 0.2476, 0.0000,</span><br><span class="line">         0.0000, 0.2462],</span><br><span class="line">        [0.2326, 0.0623, 0.0000, 0.2878, 0.2767, 0.0000, 0.0000, 0.4339, 0.0302,</span><br><span class="line">         0.1634, 0.5649, 0.0000, 0.2025, 0.4473, 0.0000, 0.6611, 0.1883, 0.0000,</span><br><span class="line">         0.0820, 0.2778],</span><br><span class="line">        [0.3325, 0.2654, 0.1091, 0.0651, 0.3425, 0.0000, 0.0000, 0.2298, 0.3872,</span><br><span class="line">         0.0342, 0.8503, 0.0937, 0.1796, 0.5007, 0.0000, 0.4030, 0.1189, 0.0000,</span><br><span class="line">         0.2048, 0.4343]], grad_fn=&lt;ReluBackward0&gt;)</span><br></pre></td></tr></table></figure><h5 id="nn-Sequential"><a href="#nn-Sequential" class="headerlink" title="nn.Sequential"></a>nn.Sequential</h5><p>nn.Sequential是一个有序的模块容器。数据按照定义好的方式顺序的通过当前模块。<br>您可以使用顺序容器来组合一个“快捷网络” ，例如：<code>seq_modules</code> .</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seq_modules = nn.Sequential(</span><br><span class="line">    flatten,</span><br><span class="line">    layer1,</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(<span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line">input_image = torch.rand(<span class="number">3</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">logits = seq_modules(input_image)</span><br></pre></td></tr></table></figure><h5 id="nn-Softmax"><a href="#nn-Softmax" class="headerlink" title="nn.Softmax"></a>nn.Softmax</h5><p>Softmax激活函数通常用在最后一个线性层，用来返回对数区间介于 [-infty, infty] 中的原始值，这些值最终被传递给 <code>nn.Softmax</code> 模块。</p><p>Softmax 激活函数将对应输出区间范围缩放在 [0, 1] 之间，<strong>表示模型对每个类别的预测概率</strong>。其中，<code>dim</code> 中所有参数指示值求和应该为 1 。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">softmax = nn.Softmax(dim = <span class="number">1</span>)</span><br><span class="line">pred_probab = softmax(logits)</span><br></pre></td></tr></table></figure><h5 id="模型的参数"><a href="#模型的参数" class="headerlink" title="模型的参数"></a>模型的参数</h5><p>神经网络往往非常的复杂，在整个网络的构建过程中，如果可以便捷的将每个部分表示出来，对于训练过程中的优化和修改相对的权重与偏差等都会有非常大的帮助。</p><p>子类化 <code>nn.Module</code> 模块可以帮助我们解决这个问题，该模块会自动跟踪模型对象中定义的所有字段，并使用模型的 <code>parameters()</code> 函数或 <code>named_parameters()</code> 函数方法访问所有参数。</p><p>在本次示例中，我们遍历每个参数，并预览它们的所有数值参数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Model structure: <span class="subst">&#123;model&#125;</span>\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Layer: <span class="subst">&#123;name&#125;</span> | Size: <span class="subst">&#123;param.size()&#125;</span> | Values : <span class="subst">&#123;param[:<span class="number">2</span>]&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Model structure: NeuralNetwork(</span><br><span class="line">  (flatten): Flatten(start_dim=1, end_dim=-1)</span><br><span class="line">  (linear_relu_stack): Sequential(</span><br><span class="line">    (0): Linear(in_features=784, out_features=512, bias=True)</span><br><span class="line">    (1): ReLU()</span><br><span class="line">    (2): Linear(in_features=512, out_features=512, bias=True)</span><br><span class="line">    (3): ReLU()</span><br><span class="line">    (4): Linear(in_features=512, out_features=10, bias=True)</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Layer: linear_relu_stack.0.weight | Size: torch.Size([512, 784]) | Values : tensor([[ 0.0273,  0.0296, -0.0084,  ..., -0.0142,  0.0093,  0.0135],</span><br><span class="line">        [-0.0188, -0.0354,  0.0187,  ..., -0.0106, -0.0001,  0.0115]],</span><br><span class="line">       device=&#x27;cuda:0&#x27;, grad_fn=&lt;SliceBackward0&gt;)</span><br><span class="line"></span><br><span class="line">Layer: linear_relu_stack.0.bias | Size: torch.Size([512]) | Values : tensor([-0.0155, -0.0327], device=&#x27;cuda:0&#x27;, grad_fn=&lt;SliceBackward0&gt;)</span><br><span class="line"></span><br><span class="line">Layer: linear_relu_stack.2.weight | Size: torch.Size([512, 512]) | Values : tensor([[ 0.0116,  0.0293, -0.0280,  ...,  0.0334, -0.0078,  0.0298],</span><br><span class="line">        [ 0.0095,  0.0038,  0.0009,  ..., -0.0365, -0.0011, -0.0221]],</span><br><span class="line">       device=&#x27;cuda:0&#x27;, grad_fn=&lt;SliceBackward0&gt;)</span><br><span class="line"></span><br><span class="line">Layer: linear_relu_stack.2.bias | Size: torch.Size([512]) | Values : tensor([ 0.0148, -0.0256], device=&#x27;cuda:0&#x27;, grad_fn=&lt;SliceBackward0&gt;)</span><br><span class="line"></span><br><span class="line">Layer: linear_relu_stack.4.weight | Size: torch.Size([10, 512]) | Values : tensor([[-0.0147, -0.0229,  0.0180,  ..., -0.0013,  0.0177,  0.0070],</span><br><span class="line">        [-0.0202, -0.0417, -0.0279,  ..., -0.0441,  0.0185, -0.0268]],</span><br><span class="line">       device=&#x27;cuda:0&#x27;, grad_fn=&lt;SliceBackward0&gt;)</span><br><span class="line"></span><br><span class="line">Layer: linear_relu_stack.4.bias | Size: torch.Size([10]) | Values : tensor([ 0.0070, -0.0411], device=&#x27;cuda:0&#x27;, grad_fn=&lt;SliceBackward0&gt;)</span><br></pre></td></tr></table></figure><h2 id="张量-Tensor"><a href="#张量-Tensor" class="headerlink" title="张量 Tensor"></a>张量 Tensor</h2><p>通过一张图初步了解常见的多维空间数据的命名方式（来源：<a href="https://youtu.be/ORMx45xqWkA?si=Njw0z1RULmPeeit9&t=17">PyTorch in 100 Seconds</a>）<br><a href="https://imgse.com/i/pilKoHf"><img src="https://z1.ax1x.com/2023/11/06/pilKoHf.png" alt="不同维度参数的命名方式"></a></p><p>Tensor 又称 张量，是一种专门的数据结构，与数组和矩阵非常相似。在 PyTorch 中，我们使用张量对比模型的输入和输出以及模型的参数进行编码。</p><p>Tensors 类似于 NumPy 中的ndarrays，不同之处在于张量可以在 GPU 或其他硬件加速器上运行。事实上，张量和 NumPy 数组通常可以共享相同的底层内存，从而消除了复制数据的需要。</p><p>张量也针对自动微分进行了优化。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h3 id="初始化张量"><a href="#初始化张量" class="headerlink" title="初始化张量"></a>初始化张量</h3><p>一般可以通过如下方式初始化 <code>Tensor</code>:</p><ul><li>直接通过数据创建</li><li>通过NumPy创建</li><li>通过继承另一个Tensor的形状和数据类型</li><li>使用随机值或常量</li></ul><p>下面分别进行介绍：</p><h4 id="直接来自数据"><a href="#直接来自数据" class="headerlink" title="直接来自数据"></a>直接来自数据</h4><p>张量可以直接从已有的数据中创建，数据类型是自动推断的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">x_data = torch.tensor(data)</span><br></pre></td></tr></table></figure><h4 id="来自另一个-Tensor"><a href="#来自另一个-Tensor" class="headerlink" title="来自另一个 Tensor"></a>来自另一个 Tensor</h4><p>新建的张量保留参考张量的部分参数（<strong>形状，数据类型</strong>），除非用显式的方式直接覆盖。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x_ones = torch.ones_like(x_data) <span class="comment"># retains the properties of x_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_rand = torch.rand_like(x_data, dtype = torch.<span class="built_in">float</span>) <span class="comment"># overrides the datatype of x_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[1, 1],</span><br><span class="line">        [1, 1]])</span><br><span class="line"></span><br><span class="line">Random Tensor:</span><br><span class="line"> tensor([[0.8823, 0.9150],</span><br><span class="line">        [0.3829, 0.9593]])</span><br></pre></td></tr></table></figure><h4 id="使用随机值或常量"><a href="#使用随机值或常量" class="headerlink" title="使用随机值或常量"></a>使用随机值或常量</h4><p><code>shape</code> 是张量维度的元组表达式。在下面的函数中，它决定了输出张量的维度：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 Tensor 的维度</span></span><br><span class="line">shape = (<span class="number">2</span>, <span class="number">3</span>, )</span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones_Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Zeros_Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random Tensor:</span><br><span class="line"> tensor([[0.3904, 0.6009, 0.2566],</span><br><span class="line">        [0.7936, 0.9408, 0.1332]])</span><br><span class="line"></span><br><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[1., 1., 1.],</span><br><span class="line">        [1., 1., 1.]])</span><br><span class="line"></span><br><span class="line">Zeros Tensor:</span><br><span class="line"> tensor([[0., 0., 0.],</span><br><span class="line">        [0., 0., 0.]])</span><br></pre></td></tr></table></figure><h3 id="张量的属性"><a href="#张量的属性" class="headerlink" title="张量的属性"></a>张量的属性</h3><p>Tensor 的属性描述了<u><strong>它们的形状</strong></u>、<u><strong>数据类型</strong></u> 和 <u><strong>存储它们的设备</strong></u>。</p><ul><li><code>tensor.shape</code></li><li><code>tensor.dtype</code></li><li><code>tensor.device</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Dtype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device of tensor: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape of tensor: torch.Size([3, 4])</span><br><span class="line">Datatype of tensor: torch.float32</span><br><span class="line">Device tensor is stored on: cpu</span><br></pre></td></tr></table></figure><h3 id="张量的操作"><a href="#张量的操作" class="headerlink" title="张量的操作"></a>张量的操作</h3><p>科学计算是深度学习领域的根本！PyTorch提供了 100+ 张量运算操作，包括算术运算、线性代数运算、矩阵运算（转职、索引、切片）、采样等。</p><p><u><strong><code>PyTorch</code> 中的所有逻辑运算都可以通过GPU进行加速运算</strong></u></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将运行设备选择为 GPU （如果你有的话）</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    tensor = tensor.to(<span class="string">&quot;cuda&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="类似-NumPy-的索引和切片操作"><a href="#类似-NumPy-的索引和切片操作" class="headerlink" title="类似 NumPy 的索引和切片操作"></a>类似 NumPy 的索引和切片操作</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tensor= torch.ones(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First row: <span class="subst">&#123;tensor[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First column: <span class="subst">&#123;tensor[:, <span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;last column: <span class="subst">&#123;tensor[..., -<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">tensor[:, <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">First row: tensor([1., 1., 1., 1.])</span><br><span class="line">First column: tensor([1., 1., 1., 1])</span><br><span class="line">Last column: tensor([1., 1., 1., 1])</span><br><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure><h4 id="Tensor-之间的连接"><a href="#Tensor-之间的连接" class="headerlink" title="Tensor 之间的连接"></a>Tensor 之间的连接</h4><p><code>torch.cat</code> 可以用于连接指定维度的张量，拥有同样功能的另一个算子是 <code>torch.stack_</code> （参考：<a href="https://pytorch.org/docs/stable/generated/torch.stack.html">torch.stack_</a>）。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 = torch.cat([tensor, tensor, tensor], dim = <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br></pre></td></tr></table></figure><h4 id="张量的算术运算"><a href="#张量的算术运算" class="headerlink" title="张量的算术运算"></a>张量的算术运算</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算两个张量之间的矩阵乘法。其中，y1, y2, y3 拥有相同的参数值</span></span><br><span class="line"><span class="comment"># `tensor.T` 返回张量的转置</span></span><br><span class="line">y1 = tensor @ tensor.T</span><br><span class="line">y2 = tensor.matmul(tensor.T)</span><br><span class="line"></span><br><span class="line">y3 = torch.rand_like(y1)</span><br><span class="line">torch.matmul(tensor, tensor.T, out = y3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将张量中的元素逐个相乘。z1, z2, z3 具有相同的值</span></span><br><span class="line">z1 = tensor * tensor</span><br><span class="line">z2 = tensor.mul(tensor)</span><br><span class="line"></span><br><span class="line">z3 = torch.rand_like(tensor)</span><br><span class="line">torch.mul(tensor, tensor, out = z3)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1],</span><br><span class="line">        [1., 0., 1., 1],</span><br><span class="line">        [1., 0., 1., 1],</span><br><span class="line">        [1., 0., 1., 1]])</span><br></pre></td></tr></table></figure><h4 id="单一元素张量"><a href="#单一元素张量" class="headerlink" title="单一元素张量"></a>单一元素张量</h4><p>如果你有一个单一元素的张量，例如希望通过将张量的所有值聚合为一个值，那么可以使用 <code>item()</code> 将其转换为 python 数值：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">agg = tensor.<span class="built_in">sum</span>()</span><br><span class="line">agg_item = agg.item()</span><br><span class="line"><span class="built_in">print</span>(agg_item, <span class="built_in">type</span>(agg_item))</span><br></pre></td></tr></table></figure><p>打印输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12.0 &lt;class &#x27;float&#x27;&gt;</span><br></pre></td></tr></table></figure><h4 id="原地操作-不通过返回的方式进行原地修改"><a href="#原地操作-不通过返回的方式进行原地修改" class="headerlink" title="原地操作(不通过返回的方式进行原地修改)"></a>原地操作(不通过返回的方式进行原地修改)</h4><p>将结果存储在操作数中的操作成为原地操作。它们由 <code>_</code> 后缀表示。例如：<code>x.copy()</code> 、 <code>x.t_()</code> ，都将直接修改 <code>x</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;tensor&#125;</span> \n&quot;</span>)</span><br><span class="line">tensor.add_(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br><span class="line"></span><br><span class="line">tensor([[6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.]])</span><br></pre></td></tr></table></figure><h3 id="Tensor-和-Numpy-二者转换"><a href="#Tensor-和-Numpy-二者转换" class="headerlink" title="Tensor 和 Numpy 二者转换"></a>Tensor 和 Numpy 二者转换</h3><p>位于 CPU 位置上的 Numpy 数组与 Tensor 可以共享同一个底层的内容空间，更改一个 tensor 会同时修改另一个 tensor 。</p><h4 id="Tensor2NumPy-array"><a href="#Tensor2NumPy-array" class="headerlink" title="Tensor2NumPy_array"></a>Tensor2NumPy_array</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = torch.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">n = t.numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印对比结果（t 代表 tensor；n 代表 numpy）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([1., 1., 1., 1., 1.])</span><br><span class="line">n: [1. 1. 1. 1. 1.]</span><br></pre></td></tr></table></figure><p>下一步，改变 tensor 中的值，同时观察 NumPy 中值的变化：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: (n)&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印对比结果（t 代表 tensor；n 代表 numpy）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([2., 2., 2., 2., 2.])</span><br><span class="line">n: [2. 2. 2. 2. 2.]</span><br></pre></td></tr></table></figure><h4 id="NumPy-array2Tensor"><a href="#NumPy-array2Tensor" class="headerlink" title="NumPy_array2Tensor"></a>NumPy_array2Tensor</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = np.ones(<span class="number">5</span>)</span><br><span class="line">t = torch.from_numpy(n)</span><br></pre></td></tr></table></figure><p>NumPy 数组中的更改回反映在张量（tensor）中</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.add(n, <span class="number">1</span>, out = n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([2., 2., 2., 2., 2.], dtype=torch.float64)</span><br><span class="line">n: [2. 2. 2. 2. 2.]</span><br></pre></td></tr></table></figure><h2 id="数据集的相关操作"><a href="#数据集的相关操作" class="headerlink" title="数据集的相关操作"></a>数据集的相关操作</h2><p>从代码的架构设计上考虑，无论是出于可读性考虑还是出于代码逻辑的模块化管理考虑，我们都希望数据集代码与模型训练代码分离。</p><p>在数据预加载上，PyTorch 提供了两个功能函数 <code>torch.utils.data.DataLoader</code> 和 <code>torch.utils.data.Dataset</code> 分别读取预加载的数据和自己的数据。</p><p><code>Dataset</code> 存储样本和对应的标签，并在 <code>DataLoader</code> 范围内包装成一个可迭代对象 <code>Dataset</code> 以便轻松访问样本。</p><blockquote><p>在 PyTorch 函数库中预先提供好了很多可供预加载的数据集（例如：FashionMNIST），这些数据集借助 <code>torch.utils.data.Dataset</code> 子类化，并实现位于特定数据的函数。它们可用于对模型进行原型设计和基准测试。可以通过如下链接访问：<a href="https://colab.research.google.com/corgiredirector?site=https://pytorch.org/vision/stable/datasets.html">Image Datasets</a>，<a href="https://colab.research.google.com/corgiredirector?site=https://pytorch.org/text/stable/datasets.html">Text Datasets</a>，<a href="https://colab.research.google.com/corgiredirector?site=https://pytorch.org/audio/stable/datasets.html">Audio Datasets</a></p></blockquote><h3 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h3><p>下面例子是从 <code>TorchVision</code> 加载 <a href="https://colab.research.google.com/corgiredirector?site=https://research.zalando.com/project/fashion_mnist/fashion_mnist/">Fashion-MNIST</a> 数据集的示例。Fashion-MNIST 由 60000 个训练样本和 10000 个测试样本组成。每个示例都包含一个 28*28 灰度图像和一个来自 10 个类之一的关联标签。</p><p>我们通过如下几个参数，对 <a href="https://colab.research.google.com/corgiredirector?site=https://pytorch.org/vision/stable/datasets.html%23fashion-mnist">FashionMNIST Dataset</a> 数据集进行加载：</p><ul><li><code>root</code> 是存储训练&#x2F;测试数据的根目录</li><li><code>train</code> 指定训练或测试数据集</li><li><code>download = TRUE</code> 允许从互联网上搜索并下载数据集，前提是 root 路径下的数据集文件不存在</li><li><code>transform</code> 和 <code>target_transform</code> 分别执行 <em>标定特征</em> 和 <em>标注转换</em></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root = <span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train = <span class="literal">True</span>,</span><br><span class="line">    download = <span class="literal">True</span>,</span><br><span class="line">    transform = ToTensor()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root = <span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train = <span class="literal">False</span>,</span><br><span class="line">    download = <span class="literal">True</span>,</span><br><span class="line">    transform = ToTensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数据集迭代和数据可视化"><a href="#数据集迭代和数据可视化" class="headerlink" title="数据集迭代和数据可视化"></a>数据集迭代和数据可视化</h3><p>使用 <code>Datasets</code> ，我们可以实现像 Python 中列表那样的手动索引 <code>training_data[index]</code>。</p><p>使用 <code>matplotlib</code> 可视化训练数据集中的样本进行展示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">labels_map = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;T-Shirt&quot;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;Trouser&quot;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&quot;Pullover&quot;</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">&quot;Dress&quot;</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">&quot;Coat&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;Sandal&quot;</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">&quot;Shirt&quot;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&quot;Sneaker&quot;</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">&quot;Bag&quot;</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">&quot;Ankle Boot&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">figure = plt.figure(figsize = (<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">cols, rows = <span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols * rows + <span class="number">1</span>):</span><br><span class="line">    sample_idx = torch.randint(<span class="built_in">len</span>(training_data), size(<span class="number">1</span>,)).item()</span><br><span class="line">    image, lable = training_data[sample_idx]</span><br><span class="line">    figure.add_subplot(rows, cols, i)</span><br><span class="line">    plt.title(lables_map[label])</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(img.squeeze(), cmap = <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.show()  <span class="comment"># 打印出来的输出为数据集图像示例展示</span></span><br></pre></td></tr></table></figure><p>打印输出：</p><p><a href="https://imgse.com/i/pilfxhV"><img src="https://z1.ax1x.com/2023/11/07/pilfxhV.png" alt="pilfxhV.png"></a></p><h3 id="创建自定义的数据集"><a href="#创建自定义的数据集" class="headerlink" title="创建自定义的数据集"></a>创建自定义的数据集</h3><p>自定义数据集必须含有三个函数：</p><ul><li><code>__init__</code></li><li><code>__len__</code></li><li><code>__gititem__</code></li></ul><p>通过下面这个示例实现了解相关函数的使用方法。</p><p>FashionMNIST 图像存储在目录 <code>img_dir</code>，其自身的标签单独存储在CSV文件 <code>annotations_file</code> 中</p><p>先看代码块部分：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torchvision.io <span class="keyword">as</span> read_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomImageDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, annotations_file, img_dir, transform = <span class="literal">None</span>, target_transform = <span class="literal">None</span></span>):</span><br><span class="line">        self.img_labels = pd.read_csv(annotations_file)</span><br><span class="line">        self.img_dir = img_dir</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_labels)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self</span>):</span><br><span class="line">        img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="number">0</span>])</span><br><span class="line">        image = read_image(img_path)</span><br><span class="line">        label = self.img_labels.iloc[idx, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            image = self.transform(image)</span><br><span class="line">        <span class="keyword">if</span> self.target_transform:</span><br><span class="line">            label = self.target_transform(label)</span><br><span class="line">        <span class="keyword">return</span> image, label</span><br></pre></td></tr></table></figure><h4 id="init"><a href="#init" class="headerlink" title="_init_"></a>_<em>init</em>_</h4><p>init 作为初始化函数，在实例化 Dataset 对象时运行一次。</p><p>我们初始化包含<strong>图像</strong>、<strong>注释文件</strong>和<strong>两个转换的目录</strong></p><p>labels.csv 文件的展示效果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tshirt1.jpg, 0</span><br><span class="line">tshirt2.jpg, 0</span><br><span class="line">......</span><br><span class="line">ankleboot999.jpg, 9</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, annotations_file, img_dir, transform = <span class="literal">None</span>, target_transform = <span class="literal">None</span></span>):</span><br><span class="line">    self.img_labels = pd.read_csv(annotations_file)</span><br><span class="line">    self.img_dir = img_dir</span><br><span class="line">    self.transform = transform</span><br><span class="line">    self.target_transform = target_transform</span><br></pre></td></tr></table></figure><h4 id="len"><a href="#len" class="headerlink" title="_len_"></a>_<em>len</em>_</h4><p>len 函数返回数据集中的样本数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.img_labels)</span><br></pre></td></tr></table></figure><h4 id="getitem"><a href="#getitem" class="headerlink" title="_getitem_"></a>_<em>getitem</em>_</h4><p>getitem 函数从给定索引目录的 <code>idx</code> 处返回数据集中的样本。</p><p>根据索引，它识别图像在磁盘上的位置，使用 <code>read_image</code>，从 csv 数据中检索相应的标签<code>self.img_labels</code>，调用它们的转换函数（前提是支持转换），并在元组中返回张量图像和相应的标签。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self</span>):</span><br><span class="line">    img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="number">0</span>])</span><br><span class="line">    image = read_image(img_path)</span><br><span class="line">    label = self.img_labels.iloc[idx, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> self.transform:</span><br><span class="line">        image = self.transform(image)</span><br><span class="line">    <span class="keyword">if</span> self.target_transform:</span><br><span class="line">        label = self.target_transform(label)</span><br><span class="line">    <span class="keyword">return</span> image, label</span><br></pre></td></tr></table></figure><h3 id="准备数据并使用-DataLoader-进行训练"><a href="#准备数据并使用-DataLoader-进行训练" class="headerlink" title="准备数据并使用 DataLoader 进行训练"></a>准备数据并使用 DataLoader 进行训练</h3><p>检索 Dataset 数据集的特征，并一次标记一个样本。</p><p>在训练模型的过程中，我们通常希望通过“小批量”的方式传递样本，在新一轮 epoch 下数据 reshuffle(洗牌) 减少模型过拟合，并使用 Python 中的 <code>multiprocessing</code> 函数来加快数据检索的速度。</p><p><code>DataLoader</code> 是一个可迭代的对象，它通过一个简单的 API 为我们抽象了这种复杂性。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size = <span class="number">64</span>, shuffle = <span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size = <span class="number">64</span>, shuffle = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="遍历-DataLoader"><a href="#遍历-DataLoader" class="headerlink" title="遍历 DataLoader"></a>遍历 DataLoader</h3><p>通过上面的步骤，我们已经将数据集加载到了 <code>DataLoader</code> 并可以根据我们的需要来遍历该数据集。</p><p>后续程序中每一次迭代都会返回一批 <code>train_features</code> 和 <code>train_labels</code>，每批结果中都包含 <code>batch_size = 64</code> 特征和标签。</p><p>在上面代码块中，我们指定了 shuffle &#x3D; True ，在我们遍历了所有批次后，数据会被洗牌（目的是为了更细粒度地控制数据加载顺序，可参考<a href="https://colab.research.google.com/corgiredirector?site=https://pytorch.org/docs/stable/data.html%23data-loading-order-and-sampler">Samplers</a>）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Display image and label.</span></span><br><span class="line">train_features, train_labels = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_dataloader))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Feature batch shape: <span class="subst">&#123;train_features.size()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Labels batch shape: <span class="subst">&#123;train_labels.size()&#125;</span>&quot;</span>)</span><br><span class="line">img = train_features[<span class="number">0</span>].squeeze()</span><br><span class="line">label = train_labels[<span class="number">0</span>]</span><br><span class="line">plt.imshow(img, cmap = <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.show()  <span class="comment"># 输出数据集中的图片</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Label: <span class="subst">&#123;label&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>数据的格式不总是按照训练机器学习算法所需要的格式出现的，因此我们需要通过<u><em><strong>转换</strong></em></u>来对数据进行一系列操作使得其适合于机器学习任务。</p><p>所有 <code>TorchVision</code> 数据集都具有两个参数：</p><ul><li><code>transform</code> 用于修改标签</li><li><code>target_transform</code> 接受包含转换逻辑的可调用对象</li></ul><p>在 <a href="https://pytorch.org/vision/stable/transforms.html">torchvision.transforms</a> 中提供了几个开箱即用的转换格式。</p><p>FashionMNIST 特征采用 PIL Image 格式，标签为整数。</p><p>在训练任务开始前，我们需要将特征处理为归一化之后的张量。</p><p>为了进行这些转换，需要使用 <code>ToTensor</code> 和 <code>Lambda</code> 函数方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor, Lambda</span><br><span class="line"></span><br><span class="line">ds = datasets.FashionMNIST(</span><br><span class="line">    root = <span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train = <span class="literal">True</span>,</span><br><span class="line">    download = <span class="literal">True</span>,</span><br><span class="line">    transform = ToTensor(),</span><br><span class="line">    target_transform = Lambda(<span class="keyword">lambda</span> y: torch.zero(<span class="number">10</span>, dtype = torch.<span class="built_in">float</span>).scatter_(<span class="number">0</span>, torch.tensor(y), value = <span class="number">1</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz</span><br><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz to data/FashionMNIST/raw/train-images-idx3-ubyte.gz</span><br><span class="line"></span><br><span class="line">  0%|          | 0/26421880 [00:00&lt;?, ?it/s]</span><br><span class="line">  0%|          | 65536/26421880 [00:00&lt;01:12, 362364.70it/s]</span><br><span class="line">  1%|          | 229376/26421880 [00:00&lt;00:38, 680532.51it/s]</span><br><span class="line">  3%|2         | 786432/26421880 [00:00&lt;00:11, 2194389.90it/s]</span><br><span class="line">  7%|7         | 1933312/26421880 [00:00&lt;00:05, 4185622.75it/s]</span><br><span class="line"> 17%|#6        | 4423680/26421880 [00:00&lt;00:02, 9599067.02it/s]</span><br><span class="line"> 25%|##5       | 6717440/26421880 [00:00&lt;00:01, 11175748.57it/s]</span><br><span class="line"> 34%|###4      | 9109504/26421880 [00:01&lt;00:01, 14174360.51it/s]</span><br><span class="line"> 44%|####3     | 11567104/26421880 [00:01&lt;00:01, 14358310.56it/s]</span><br><span class="line"> 53%|#####2    | 13959168/26421880 [00:01&lt;00:00, 16463421.66it/s]</span><br><span class="line"> 62%|######2   | 16449536/26421880 [00:01&lt;00:00, 15864345.49it/s]</span><br><span class="line"> 71%|#######1  | 18776064/26421880 [00:01&lt;00:00, 17449238.29it/s]</span><br><span class="line"> 81%|########  | 21397504/26421880 [00:01&lt;00:00, 16758523.84it/s]</span><br><span class="line"> 90%|########9 | 23691264/26421880 [00:01&lt;00:00, 18055860.39it/s]</span><br><span class="line">100%|##########| 26421880/26421880 [00:01&lt;00:00, 13728491.83it/s]</span><br><span class="line">Extracting data/FashionMNIST/raw/train-images-idx3-ubyte.gz to data/FashionMNIST/raw</span><br><span class="line"></span><br><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz</span><br><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz to data/FashionMNIST/raw/train-labels-idx1-ubyte.gz</span><br><span class="line"></span><br><span class="line">  0%|          | 0/29515 [00:00&lt;?, ?it/s]</span><br><span class="line">100%|##########| 29515/29515 [00:00&lt;00:00, 327895.25it/s]</span><br><span class="line">Extracting data/FashionMNIST/raw/train-labels-idx1-ubyte.gz to data/FashionMNIST/raw</span><br><span class="line"></span><br><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz</span><br><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz to data/FashionMNIST/raw/t10k-images-idx3-ubyte.gz</span><br><span class="line"></span><br><span class="line">  0%|          | 0/4422102 [00:00&lt;?, ?it/s]</span><br><span class="line">  1%|1         | 65536/4422102 [00:00&lt;00:11, 363267.41it/s]</span><br><span class="line">  5%|5         | 229376/4422102 [00:00&lt;00:06, 683985.17it/s]</span><br><span class="line"> 19%|#8        | 819200/4422102 [00:00&lt;00:01, 2304448.10it/s]</span><br><span class="line"> 33%|###3      | 1474560/4422102 [00:00&lt;00:00, 2999709.36it/s]</span><br><span class="line"> 83%|########2 | 3670016/4422102 [00:00&lt;00:00, 7976134.77it/s]</span><br><span class="line">100%|##########| 4422102/4422102 [00:00&lt;00:00, 5985529.02it/s]</span><br><span class="line">Extracting data/FashionMNIST/raw/t10k-images-idx3-ubyte.gz to data/FashionMNIST/raw</span><br><span class="line"></span><br><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz</span><br><span class="line">Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz to data/FashionMNIST/raw/t10k-labels-idx1-ubyte.gz</span><br><span class="line"></span><br><span class="line">  0%|          | 0/5148 [00:00&lt;?, ?it/s]</span><br><span class="line">100%|##########| 5148/5148 [00:00&lt;00:00, 39473998.16it/s]</span><br><span class="line">Extracting data/FashionMNIST/raw/t10k-labels-idx1-ubyte.gz to data/FashionMNIST/raw</span><br></pre></td></tr></table></figure><h3 id="ToTensor"><a href="#ToTensor" class="headerlink" title="ToTensor()"></a>ToTensor()</h3><p><a href="https://pytorch.org/vision/stable/transforms.html#torchvision.transforms.ToTensor">ToTensor</a> 将 PIL 图像 或 NumPy <code>ndarray</code> 转换为 <code>FloatTensor</code>. 并在[0., 1.] 范围内缩放图像的像素空间。</p><h3 id="Lambda-转换"><a href="#Lambda-转换" class="headerlink" title="Lambda 转换"></a>Lambda 转换</h3><p>Lambda 函数允许任意用户定义 lambda 函数。在这里，我们定义了一个函数，将整数转换为 one-hot 编码的张量。</p><p>Lambda首先创建一个大小为10（我们数据集中的标签数量）的零向量，并调用 <a href="https://pytorch.org/docs/stable/generated/torch.Tensor.scatter_.html">scatter_</a> 函数在索引 <code>y</code> 上分配标签 <code>value = 1</code>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_transform = Lambda(<span class="keyword">lambda</span> y:torch.zeros(</span><br><span class="line">    <span class="number">10</span>, dtype = torch.<span class="built_in">float</span>).scatter_(dim = <span class="number">0</span>, index = torch.tensor(y), value = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><blockquote><p>阅读延伸：<a href="https://pytorch.org/vision/stable/transforms.html">torchvision.transforms API</a></p></blockquote><h2 id="（核心内容）自动微分-TORCH-AUTOGRAD"><a href="#（核心内容）自动微分-TORCH-AUTOGRAD" class="headerlink" title="（核心内容）自动微分(TORCH.AUTOGRAD)"></a>（核心内容）自动微分(<code>TORCH.AUTOGRAD</code>)</h2><p>在训练神经网络时，常用的算法是<strong>反向传播</strong>。在该算法中，参数（模型权重）根据损失函数相对于给定参数的<strong>梯度</strong>进行调整。</p><p>为了计算这些梯度，PyTorch 有一个内置的用于自动计算微分方程的引擎，称为 <code>torch.autograd</code> .</p><p>它支持任何计算图的梯度自动运算。</p><p>下面距离一个最简单的单层神经网络，其中包含输入 <code>x</code>、参数 <code>w</code> 和 <code>b</code>，以及一些损失函数。可以在 PyTorch 中按以下方式定义它：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>) <span class="comment"># input tensor</span></span><br><span class="line">y = torch.zeros(<span class="number">3</span>) <span class="comment"># expected output</span></span><br><span class="line">w = torch.randn(<span class="number">5</span>, <span class="number">3</span>, requires_grad = <span class="literal">True</span>)</span><br><span class="line">b = torch.randn(<span class="number">3</span>, requires_grad = <span class="literal">True</span>)</span><br><span class="line">z = torch.matmul(x, w) + b</span><br><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y) </span><br></pre></td></tr></table></figure><h3 id="张量、函数、计算图"><a href="#张量、函数、计算图" class="headerlink" title="张量、函数、计算图"></a>张量、函数、计算图</h3><p>上一小节的代码框中实现的损失函数计算流程如下图所示：</p><p><img src="https://pytorch.org/tutorials/_images/comp-graph.png" alt="计算损失函数"></p><p>在上面网络中，<code>w</code> 和 <code>b</code> 是我们需要优化的参数。因此，我们需要能够计算这些变量损失函数的梯度。</p><p>为了做到这些点，我们设置了这些张量的 <code>requires_grad</code> 函数来定义其属性。</p><blockquote><p>设置张量的值有两种方式：一种是在生成张量的时候使用 <code>requires_grad</code> 进行初始化设置；另一种是在后续使用 <code>x.requires_grad_(True)</code> 函数。</p></blockquote><p>用来构造计算图的函数实际上是类 <code>Function</code> 的对象。该对象指导如何计算正向函数，以及如何在反向传播步骤中计算其导数。对向后传播函数的引起存储在张量的属性中的 <code>grad_fn</code>。您可以在PyTorch的<a href="https://colab.research.google.com/corgiredirector?site=https://pytorch.org/docs/stable/autograd.html%23function">官方文档</a>中找到更多信息 <code>Function</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Gradient function for z = <span class="subst">&#123;z.grad_fn&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Gradient function for loss = <span class="subst">&#123;loss.grad_fn&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gradient function for z = &lt;AddBackward0 object at 0x7d800ac85840&gt;</span><br><span class="line">Gradient function for loss = &lt;BinaryCrossEntropyWithLogitsBackward0 object at 0x7d800ac85ea0&gt;</span><br></pre></td></tr></table></figure><h3 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h3><p>为了优化神经网络中的参数权重，我们需要计算损失函数相对于参数的导数，即我们需要在固定 <code>x</code> 和 <code>y</code> 值的情况下，求出 $\frac{\partial loss}{\partial w}$ 和 $\frac{\partial loss}{\partial b}$。</p><p>为了求出上面的导数，我们需要调用函数 <code>loss.backward()</code>，然后从 <code>w.grad</code> 和 <code>b.grad</code> 中检索权重和偏置的数值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0.3287, 0.0101, 0.0988],</span><br><span class="line">        [0.3287, 0.0101, 0.0988],</span><br><span class="line">        [0.3287, 0.0101, 0.0988],</span><br><span class="line">        [0.3287, 0.0101, 0.0988],</span><br><span class="line">        [0.3287, 0.0101, 0.0988]])</span><br><span class="line">tensor([0.3287, 0.0101, 0.0988])</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>可以通过将参数 <code>requires_grad</code> 的 <code>grad</code> 属性设置为 <code>True</code> 来或测计算图的叶节点属性。对于计算图中的所有其他节点，梯度将不可用。</p></li><li><p>PyTorch考虑性能上的原因，在给定图形上只能调用 <code>backward</code> 调用一次梯度计算。如果我们需要再同一个图上执行多个 <code>backward</code> 调用，我们需要参数传递给 <code>retain_graph = True</code>，再调用 <code>backward</code> 。</p></li></ul></blockquote><h3 id="禁用梯度追踪"><a href="#禁用梯度追踪" class="headerlink" title="禁用梯度追踪"></a>禁用梯度追踪</h3><p>默认情况下，所有张量都在 <code>require_grad = True</code> 跟踪其计算历史并支持梯度计算。但是，在某些情况下，只想将模型应用于默写输入数据时，即我们只想通过网络进行前向计算。我们可以通过将计算代码加上 <code>torch.no_grad()</code> 还书，用来停止跟踪计算。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">z = torch.matmul(x, w) +b</span><br><span class="line"><span class="built_in">print</span>(z.requires_grad) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    z = torch.matmul(x, w) + b</span><br><span class="line"><span class="built_in">print</span>(z.requires_grad) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>另一种方法是在张量上使用 <code>detach()</code> 方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z = torch.matmul(x, w) + b</span><br><span class="line">z_det = z.detach()</span><br><span class="line"><span class="built_in">print</span>(z_det.requires_grad) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>考虑要禁用梯度跟踪的情况：</p><ul><li>将神经网络中的某些参数标记为冻结参数</li><li>为了优化计算速度，在只进行前向传播时禁用梯度跟踪的选项</li></ul><h3 id="计算图部分扩展阅读"><a href="#计算图部分扩展阅读" class="headerlink" title="计算图部分扩展阅读"></a>计算图部分扩展阅读</h3><p>（留白，前面的区域以后再探索吧~）</p><h3 id="可选阅读：张量梯度-和-雅阁比积-Jacobian-Products"><a href="#可选阅读：张量梯度-和-雅阁比积-Jacobian-Products" class="headerlink" title="可选阅读：张量梯度 和 雅阁比积(Jacobian_Products)"></a>可选阅读：张量梯度 和 雅阁比积(Jacobian_Products)</h3><p>（留白，前面的区域以后再探索吧~）</p><h2 id="（重要）优化模型参数"><a href="#（重要）优化模型参数" class="headerlink" title="（重要）优化模型参数"></a>（重要）优化模型参数</h2><p>在拥有了模型和数据之后，就可以通过优化数据参数来训练、验证和测试我们的模型了。训练模型是一个带带过程，每次迭代中，模型都会对输出进行*<u>猜测</u>*，计算其猜测中的误差，计算其猜测中的误差（损失），收集误差对参数的导数（上一节中进行的工作），并使用梯度下降这些参数。</p><p>更详细的视频讲解，可以参考 <a href="https://www.youtube.com/watch?v=tIeHLnjs5U8">backpropagation from 3Blue1Brown</a></p><h3 id="先决条件代码"><a href="#先决条件代码" class="headerlink" title="先决条件代码"></a>先决条件代码</h3><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><h3 id="优化循环"><a href="#优化循环" class="headerlink" title="优化循环"></a>优化循环</h3><h3 id="全过程数据跟踪"><a href="#全过程数据跟踪" class="headerlink" title="全过程数据跟踪"></a>全过程数据跟踪</h3><h2 id="保存、加载和使用模型"><a href="#保存、加载和使用模型" class="headerlink" title="保存、加载和使用模型"></a>保存、加载和使用模型</h2><h3 id="保存-x2F-加载模型权重"><a href="#保存-x2F-加载模型权重" class="headerlink" title="保存&#x2F;加载模型权重"></a>保存&#x2F;加载模型权重</h3><h3 id="通过模型的形状参数进行保存-x2F-加载"><a href="#通过模型的形状参数进行保存-x2F-加载" class="headerlink" title="通过模型的形状参数进行保存&#x2F;加载"></a>通过模型的形状参数进行保存&#x2F;加载</h3><h2 id="在-PyTorch-中保存和加载常规-Checkpoint"><a href="#在-PyTorch-中保存和加载常规-Checkpoint" class="headerlink" title="在 PyTorch 中保存和加载常规 Checkpoint"></a>在 PyTorch 中保存和加载常规 Checkpoint</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-导入加载数据所需要的库"><a href="#1-导入加载数据所需要的库" class="headerlink" title="1.导入加载数据所需要的库"></a>1.导入加载数据所需要的库</h4><h4 id="2-定义和初始化神经网络"><a href="#2-定义和初始化神经网络" class="headerlink" title="2.定义和初始化神经网络"></a>2.定义和初始化神经网络</h4><h4 id="3-初始化优化器"><a href="#3-初始化优化器" class="headerlink" title="3.初始化优化器"></a>3.初始化优化器</h4><h4 id="4-保存常规检查点"><a href="#4-保存常规检查点" class="headerlink" title="4.保存常规检查点"></a>4.保存常规检查点</h4><h4 id="5-加载常规检查点"><a href="#5-加载常规检查点" class="headerlink" title="5.加载常规检查点"></a>5.加载常规检查点</h4><h2 id="从-Checkpoint-中加载-nn-Module-的技巧"><a href="#从-Checkpoint-中加载-nn-Module-的技巧" class="headerlink" title="从 Checkpoint 中加载 nn.Module 的技巧"></a>从 Checkpoint 中加载 <code>nn.Module</code> 的技巧</h2><h3 id="活用-torch-load-mmap-True"><a href="#活用-torch-load-mmap-True" class="headerlink" title="活用 torch.load(mmap = True)"></a>活用 <code>torch.load(mmap = True)</code></h3><h3 id="活用-torch-device-quot-meta-quot"><a href="#活用-torch-device-quot-meta-quot" class="headerlink" title="活用 torch.device(&quot;meta&quot;)"></a>活用 <code>torch.device(&quot;meta&quot;)</code></h3><h3 id="活用-load-state-dict-assign-True"><a href="#活用-load-state-dict-assign-True" class="headerlink" title="活用 load_state_dict(assign = True)"></a>活用 <code>load_state_dict(assign = True)</code></h3><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#pytorch-%E5%9F%BA%E7%A1%80&quot;&gt;Pytorch 基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8&quot;&gt;快速入门&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Deeplearning" scheme="https://zade23.github.io/categories/Deeplearning/"/>
    
    
    <category term="PyTorch" scheme="https://zade23.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>工具网站</title>
    <link href="https://zade23.github.io/2023/10/18/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"/>
    <id>https://zade23.github.io/2023/10/18/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/</id>
    <published>2023-10-18T09:04:52.000Z</published>
    <updated>2024-03-21T06:39:50.153Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%86%85%E5%AE%B9%E5%88%86%E7%B1%BB">内容分类</a><ul><li><a href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99">学习资源网站</a><ul><li><a href="#aigc">aigc</a></li><li><a href="#llm">llm</a></li><li><a href="#tts">tts</a></li><li><a href="#rl">rl</a></li><li><a href="#diffusion">diffusion</a></li><li><a href="#huggingface">huggingface</a></li><li><a href="#awesome">awesome</a></li><li><a href="#%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80">数学基础</a></li><li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a></li><li><a href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83">深度学习&#x2F;模型训练</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5%E5%8F%AF%E8%A7%86%E5%8C%96">抽象概念可视化</a></li><li><a href="#%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95">传统算法</a></li><li><a href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a></li><li><a href="#%E7%94%B5%E5%AD%90%E4%B9%A6">电子书</a></li></ul></li><li><a href="#%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99">工具网站</a><ul><li><a href="#%E5%9C%A8%E7%BA%BF%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B">在线大语言模型</a></li><li><a href="#%E5%9C%A8%E7%BA%BFapi">在线api</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86">数据集</a></li><li><a href="#%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86">音频处理</a></li><li><a href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86">视频处理</a></li><li><a href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86">图像处理</a></li><li><a href="#%E8%AE%BE%E8%AE%A1">设计</a></li><li><a href="#%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7">下载工具</a></li><li><a href="#%E6%A0%BC%E5%BC%8F%E5%8E%8B%E7%BC%A9">格式压缩</a></li></ul></li></ul></li></ul><hr><h2 id="内容分类"><a href="#内容分类" class="headerlink" title="内容分类"></a>内容分类</h2><h3 id="学习资源网站"><a href="#学习资源网站" class="headerlink" title="学习资源网站"></a>学习资源网站</h3><h4 id="aigc"><a href="#aigc" class="headerlink" title="aigc"></a>aigc</h4><ul><li>【关于AIGC的各种精选教程和资源，既适合初学者也适合进阶AI爱好者】<a href="github.com/luban-agi/Awesome-AIGC-Tutorials/blob/main/README_zh.md">github.com&#x2F;luban-agi&#x2F;Awesome-AIGC-Tutorials&#x2F;blob&#x2F;main&#x2F;README_zh.md</a></li></ul><h4 id="llm"><a href="#llm" class="headerlink" title="llm"></a>llm</h4><ul><li><p>【收集各种垂直领域的大语言模型】<a href="https://github.com/luban-agi/Awesome-Domain-LLM">Awesome Domain LLM</a></p></li><li><p>【关于大型语言模型(LLM)的一切，包括了LLMs的入门、微调方法、多模态模型、稳定扩散、注意力机制优化和数据效率等方面的信息，从nanoGPT到LoRA、QLoRA、RLHF到CLIP等多模态模型】<a href="github.com/tianlinxu312/Everything-about-LLMs">Everything-about-LLMs</a></p></li><li><p>【提示工程实例：用实际项目学习提示工程技术，从大型语言模型获得更好的结果，内容涵盖零样本和少样本提示，分隔符，步骤编号，角色提示，思维链(CoT)提示等】 <a href="https://realpython.com/practical-prompt-engineering/">《Prompt Engineering: A Practical Example – Real Python》</a></p></li></ul><h4 id="tts"><a href="#tts" class="headerlink" title="tts"></a>tts</h4><ul><li>【如何在浏览器中处理音视频】<a href="https://hughfenghen.github.io/tag/WebAV/">Web 音视频系列</a></li><li>【基于华为诺亚方舟实验室Grad-TTS的Grad-SVC】<a href="https://github.com/PlayVoice/Grad-SVC">https://github.com/PlayVoice/Grad-SVC</a></li><li>【台大课程《深度学习音乐分析与生成》资料】 <a href="http://github.com/affige/DeepMIR">github.com&#x2F;affige&#x2F;DeepMIR</a></li><li>【大型音频模型相关文献资源列表】 <a href="http://github.com/EmulationAI/awesome-large-audio-models">github.com&#x2F;EmulationAI&#x2F;awesome-large-audio-models</a></li></ul><h4 id="rl"><a href="#rl" class="headerlink" title="rl"></a>rl</h4><ul><li>【Generative Agents with Llama2】<a href="https://github.com/rlancemartin/generative_agents">https://github.com/rlancemartin/generative_agents</a></li></ul><h4 id="diffusion"><a href="#diffusion" class="headerlink" title="diffusion"></a>diffusion</h4><ul><li>【扩散模型相关论文资源列表，涵盖了文本到视频生成、文本引导视频编辑、个性化视频生成、视频预测等方面】 <a href="http://github.com/ChenHsing/Awesome-Video-Diffusion-Models">github.com&#x2F;ChenHsing&#x2F;Awesome-Video-Diffusion-Models</a></li><li>【3D Diffusion相关文献列表】 <a href="http://github.com/cwchenwang/awesome-3d-diffusion">github.com&#x2F;cwchenwang&#x2F;awesome-3d-diffusion</a></li></ul><h4 id="huggingface"><a href="#huggingface" class="headerlink" title="huggingface"></a>huggingface</h4><ul><li>【Hugging Face - Learn】<a href="https://huggingface.co/learn">https://huggingface.co/learn</a></li></ul><h4 id="awesome"><a href="#awesome" class="headerlink" title="awesome"></a>awesome</h4><ul><li>【收集各种生成式 AI 的教程】<a href="https://github.com/luban-agi/Awesome-AIGC-Tutorials">Awesome AIGC Tutorials</a></li></ul><h4 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h4><ul><li>【给程序员的线性代数指南】<a href="https://coffeemug.github.io/spakhm.com/posts/01-lingalg-p1/linalg-p1.html">Linear Algebra for programmers</a></li></ul><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><ul><li>【ML Papers Explained：机器学习论文解析】 <a href="http://github.com/dair-ai/ML-Papers-Explained">github.com&#x2F;dair-ai&#x2F;ML-Papers-Explained</a></li></ul><h4 id="深度学习-x2F-模型训练"><a href="#深度学习-x2F-模型训练" class="headerlink" title="深度学习&#x2F;模型训练"></a>深度学习&#x2F;模型训练</h4><ul><li>【Batched LoRAs：通过同一批次的多个 LoRA 路由推理，最大化 GPU 利用率】<a href="github.com/sabetAI/BLoRA">Batched LoRAs - batched</a></li></ul><h4 id="抽象概念可视化"><a href="#抽象概念可视化" class="headerlink" title="抽象概念可视化"></a>抽象概念可视化</h4><ul><li>【机器学习MachineLearning】<a href="http://www.r2d3.us/">www.r2d3.us</a></li><li>【波Waveforms】<a href="https://pudding.cool/2018/02/waveforms/">Let’s Learn About Waveforms</a></li></ul><h4 id="传统算法"><a href="#传统算法" class="headerlink" title="传统算法"></a>传统算法</h4><ul><li>【开源算法库Algorithms】<a href="https://the-algorithms.com/">The Algorithms</a></li></ul><h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><ul><li><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><ul><li>【Python官方文档】<a href="https://docs.python.org/zh-cn/3/tutorial/index.html">Python语法官方文档</a></li><li>【从Python内置函数理解Python】<a href="https://tushar.lol/post/builtins/">Understanding all of Python, through its builtins</a></li><li>【GraphLearn-for-PyTorch(GLT)：PyTorch图学习库，使分布式 GNN 训练和推理变得简单高效】’GraphLearn-for-PyTorch(GLT) <a href="github.com/alibaba/graphlearn-for-pytorch">A graph learning library for PyTorch that makes distributed GNN training and inference easy and efficient</a></li></ul></li><li><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><ul><li>【C++在线学习】<a href="https://www.learncpp.com/">Learn C++ – Skill up with our free tutorials</a></li></ul></li></ul><h4 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h4><ul><li>(图书馆)【zlibrary】<a href="https://zh.zlibrary-china.se/">Z-Library – the world’s largest e-book library. Your gateway to knowledge and culture.</a></li><li>【免费书《人工智能：计算Agent基础，(第三版)》】<a href="https://artint.info/3e/html/ArtInt3e.html">《Artificial Intelligence: Foundations of Computational Agents,  3rd Edition》David L. Poole and Alan K. Mackworth (2023)</a></li><li>【配有动画的数据结构与算法电子书】<a href="https://github.com/krahets/hello-algo">Hello 算法</a></li></ul><h3 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h3><h4 id="在线大语言模型"><a href="#在线大语言模型" class="headerlink" title="在线大语言模型"></a>在线大语言模型</h4><ul><li><a href="http://wenxin.baidu.com/">百度（文心一言）</a></li><li><a href="http://doubao.com/">抖音（云雀大模型）</a></li><li><a href="http://chatglm.cn/">智谱AI（GLM大模型）</a></li><li><a href="http://xihe.mindspore.cn/">中科院（紫东太初大模型）</a></li><li><a href="http://baichuan-ai.com/">百川智能（百川大模型）</a></li><li><a href="https://chat.openai.com/">ChatGPT</a></li><li><a href="https://poe.com/">Poe</a></li><li><a href="https://passport.xfyun.cn/">讯飞星火</a></li><li><a href="https://bard.google.com/">谷歌bard</a></li><li><a href="https://qianwen.aliyun.com/">阿里通义千问</a></li></ul><h4 id="在线api"><a href="#在线api" class="headerlink" title="在线api"></a>在线api</h4><ul><li>【收集各种 AI 工具和资源】<a href="https://www.aihub.cn/">AIHub</a></li><li>【免费AI API列表】<a href="http://github.com/NovaOSS/free-ai-apis">free-ai-apis</a></li><li>【作文批改：使用GPT4对雅思托福作文判分和批改】<a href="https://www.essay.art/">https://www.essay.art/</a></li></ul><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><ul><li>【OpenDataLab 为国产大模型提供高质量的开放数据集】<a href="https://opendatalab.com/home">OpenDataLab</a></li></ul><h4 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h4><ul><li>【Whisper:英语音频转成文本的在线工具】<a href="https://huggingface.co/spaces/Xenova/whisper-web">Whisper Web</a></li></ul><h4 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h4><ul><li>【Spikes Studio】<a href="https://spikes.studio/">https://spikes.studio/</a></li></ul><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><ul><li>【在线体验-图像分割算法Meta-SegementAnything】<a href="https://segment-anything.com/demo">Segment Anything</a></li><li>【SDXL在线体验】<a href="https://www.stablediffusionai.ai/">StableDiffusion XL 体验站</a></li><li>【nutsh：旨在通过人工反馈进行视觉学习的平台，具有用户友好的界面和 API，支持一系列视觉模式、多样化的人工输入方法以及基于人工反馈的学习机制】<a href="https://nutsh.ai/docs/">Nutsh</a></li></ul><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><ul><li>【中文的图标搜索引擎，作者利用 ChatGPT 翻译了 Iconify 的 18 万个图标名】<a href="https://yesicon.app/">yesicon</a></li><li>【JupyterCAD - 用于3D几何建模的JupyterLab扩展】<a href="https://github.com/QuantStack/jupytercad">https://github.com/QuantStack/jupytercad</a></li><li>【图标搜索引擎收入了10万+的图标】<a href="https://iconbuddy.app/">Iconbuddy — 180K+ open source icons</a></li><li>【AI漫画|可选择漫画风格和页面布局】<a href="https://huggingface.co/spaces/jbilcke-hf/ai-comic-factory">AI Comic Factory - a Hugging Face Space by jbilcke-hf</a></li><li>【Figma在线版】<a href="https://www.figma.com/files/recents-and-sharing/recently-viewed">Figma</a></li></ul><h4 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h4><ul><li>【YouTube视频解析下载 】<a href="https://snapsave.io/zh-tw18">snapsave.io</a></li><li>【bilibili视频下载】<a href="https://bili.iiilab.com/">bili.iiilab</a></li></ul><h4 id="格式压缩"><a href="#格式压缩" class="headerlink" title="格式压缩"></a>格式压缩</h4><ul><li>【图片压缩软件】<a href="https://www.ticompressor.com/online/">Topspeed Image Compressor 在线压缩</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%86%85%E5%AE%B9%E5%88%86%E7%B1%BB&quot;&gt;内容分类&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99&quot;&gt;</summary>
      
    
    
    
    
    <category term="工具网站" scheme="https://zade23.github.io/tags/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>Python元组集合字典</title>
    <link href="https://zade23.github.io/2023/10/18/Python%E5%85%83%E7%BB%84%E9%9B%86%E5%90%88%E5%AD%97%E5%85%B8/"/>
    <id>https://zade23.github.io/2023/10/18/Python%E5%85%83%E7%BB%84%E9%9B%86%E5%90%88%E5%AD%97%E5%85%B8/</id>
    <published>2023-10-18T08:20:18.000Z</published>
    <updated>2024-03-14T02:59:36.156Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-%E5%85%83%E7%BB%84">1. 元组</a><ul><li><a href="#11-%E5%85%83%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">1.1 元组的初始化</a></li><li><a href="#12-%E5%85%83%E7%BB%84%E7%9A%84%E8%A7%A3%E5%8C%85">1.2 元组的解包</a></li><li><a href="#13-%E5%85%83%E7%BB%84%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C">1.3 元组的其他操作</a></li></ul></li><li><a href="#2-%E9%9B%86%E5%90%88">2. 集合</a><ul><li><a href="#21-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">2.1 集合的初始化</a></li><li><a href="#22-%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">2.2 集合的常用操作</a></li><li><a href="#23-%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88">2.3 使用<code>for</code>循环遍历集合</a></li></ul></li><li><a href="#3-%E5%AD%97%E5%85%B8">3. 字典</a><ul><li><a href="#31-%E5%AD%97%E5%85%B8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">3.1 字典的初始化</a></li><li><a href="#32-%E5%AD%97%E5%85%B8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">3.2 字典的常用操作</a></li><li><a href="#33-%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8">3.3 使用<code>for</code>循环遍历字典</a></li></ul></li><li><a href="#4-%E4%BD%9C%E4%B8%9A%E6%89%A9%E5%B1%95">4. 作业扩展</a></li></ul><hr><h3 id="1-元组"><a href="#1-元组" class="headerlink" title="1. 元组"></a>1. 元组</h3><p>元组跟 <u>列表</u> 类似，只是不支持动态添加、删除元素，以及不能修改元素。</p><h4 id="1-1-元组的初始化"><a href="#1-1-元组的初始化" class="headerlink" title="1.1 元组的初始化"></a>1.1 元组的初始化</h4><p>元组需要用小括号括起来，中间的元素用逗号隔开。</p><p><strong>注意</strong>:如果初始化只包含一个元素的元组，需要在该元素后添加逗号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = ()  <span class="comment"># 初始化一个空元组</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 含有2个整数的元组</span></span><br><span class="line">c = <span class="number">6</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">3.14</span>  <span class="comment"># 小括号可以省略，等价于(6, &quot;Python&quot;, 3.14)</span></span><br><span class="line">d = (<span class="number">5</span>,)  <span class="comment"># 注意不能写成(5)，(5)表示整数5</span></span><br><span class="line">e = <span class="number">5</span>,  <span class="comment"># 等价于(5,)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e)</span><br></pre></td></tr></table></figure><h4 id="1-2-元组的解包"><a href="#1-2-元组的解包" class="headerlink" title="1.2 元组的解包"></a>1.2 元组的解包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&quot;Hello!&quot;</span>  <span class="comment"># 初始化一个元组</span></span><br><span class="line">x, y, z = t  <span class="comment"># 将元组解包，将元组内的三个值按顺序赋值给x、y、z</span></span><br><span class="line"><span class="built_in">print</span>(x, y, z)</span><br></pre></td></tr></table></figure><p>所以，判断语句中的交换操作，本质上是元组的解包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">3</span>, <span class="number">4</span>  <span class="comment"># 将元组(3, 4)解包，分别赋值给a、b</span></span><br><span class="line">a, b = b, a  <span class="comment"># 将元组(b, a)解包，分别赋值给a、b</span></span><br></pre></td></tr></table></figure><p>同样地，函数中函数返回多个值，本质上也是返回了一个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y, x * y  <span class="comment"># 等价于 return (x + y, x * y)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, y = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">s, p = calc(x, y)  <span class="comment"># 将(x + y, x * y)解包，分别赋值给s、p</span></span><br><span class="line"><span class="built_in">print</span>(s, p)</span><br></pre></td></tr></table></figure><h4 id="1-3-元组的其他操作"><a href="#1-3-元组的其他操作" class="headerlink" title="1.3 元组的其他操作"></a>1.3 元组的其他操作</h4><p>元组的下标访问元素、循环遍历、切片、加法和乘法运算等操作，都与列表相同。</p><h3 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h3><p>集合是Python中最常用的数据结构之一，用来存储不同元素。<br>注意，集合中的元素是无序的。</p><h4 id="2-1-集合的初始化"><a href="#2-1-集合的初始化" class="headerlink" title="2.1 集合的初始化"></a>2.1 集合的初始化</h4><p>创建集合用花括号或<code>set()</code>函数。注意：创建空集合只能用<code>set()</code>，不能用<code>&#123;&#125;</code>，因为<code>&#123;&#125;</code>创建的是空字典，会在下一小节里介绍字典。</p><p>集合常见的初始化方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;  <span class="comment"># 会自动去除重复元素</span></span><br><span class="line"><span class="built_in">print</span>(basket)  <span class="comment"># 重复的元素已经去除了</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>()  <span class="comment"># 初始化一个空列表</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">b = <span class="built_in">set</span>(a)  <span class="comment"># 将列表转化成集合，一般是为了去重。</span></span><br><span class="line">c = <span class="built_in">list</span>(b)  <span class="comment"># 将集合转化回列表</span></span><br><span class="line"><span class="built_in">print</span>(b, c)</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;abracadabra&quot;</span></span><br><span class="line">a = <span class="built_in">set</span>(x)  <span class="comment"># 将字符串中的每个字符存到集合中</span></span><br><span class="line">b = <span class="built_in">str</span>(a)  <span class="comment"># 注意，这里并不能将集合转化回原字符串，而是用格式化表示集合中的内容</span></span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure><h4 id="2-2-集合的常用操作"><a href="#2-2-集合的常用操作" class="headerlink" title="2.2 集合的常用操作"></a>2.2 集合的常用操作</h4><p>假设<code>a</code>表示一个集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(a) 返回集合中包含的元素数量。</span><br><span class="line">a.add(x) 在集合中添加一个元素。</span><br><span class="line">a.remove(x) 删除集合中的x，如果x不存在，则报异常。</span><br><span class="line">a.discard(x) 删除集合中的x，如果x不存在，则不进行任何操作。</span><br><span class="line">x <span class="keyword">in</span> a 判断x是否在a中。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 输出3</span></span><br><span class="line"></span><br><span class="line">a.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;1, 2, 3, 4&#125;，注意集合中的元素是无序的。</span></span><br><span class="line"></span><br><span class="line">a.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;1, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">a.remove(<span class="number">5</span>)  <span class="comment"># 因为5不存在，所以会报异常</span></span><br><span class="line"></span><br><span class="line">a.discard(<span class="number">5</span>)  <span class="comment"># 因为5不存在，所以不进行任何操作</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># &#123;1, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-使用for循环遍历集合"><a href="#2-3-使用for循环遍历集合" class="headerlink" title="2.3 使用for循环遍历集合"></a>2.3 使用<code>for</code>循环遍历集合</h4><p>类似于列表，集合也可以用<code>for ... in ...</code>的形式遍历。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:  <span class="comment"># 循环遍历整个集合</span></span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h3><p>字典是Python中最常用的数据结构之一，用来存储映射关系。<br>注意，字典中的元素是无序的。</p><p>不同于列表，字典是以<code>key</code>进行索引的，可以将每个<code>key</code>映射到某个<code>value</code>。<code>key</code>可以是任何不可变类型，常用可以作为<code>key</code>的类型有数字和字符串。列表因为是可变的，所以不能作为<code>key</code>。<code>value</code>可以是任意类型。</p><h4 id="3-1-字典的初始化"><a href="#3-1-字典的初始化" class="headerlink" title="3.1 字典的初始化"></a>3.1 字典的初始化</h4><p>创建字典用花括号或<code>dict()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;  <span class="comment"># 创建一个字典</span></span><br><span class="line"><span class="built_in">print</span>(tel)  <span class="comment"># 输出 &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>()  <span class="comment"># 创建一个空字典</span></span><br><span class="line">a[<span class="number">123</span>] = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line">a[<span class="number">456</span>] = <span class="string">&quot;def&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;123: &#x27;abc&#x27;, 456: &#x27;def&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">list</span>(a)  <span class="comment"># 将字典的关键字转化成列表</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出[123, 456]</span></span><br></pre></td></tr></table></figure><h4 id="3-2-字典的常用操作"><a href="#3-2-字典的常用操作" class="headerlink" title="3.2 字典的常用操作"></a>3.2 字典的常用操作</h4><p>假设<code>a</code>表示一个字典。</p><ul><li><code>len(a)</code>：返回字典中的元素对数。</li><li><code>a[x]</code>：获取关键字<code>x</code>对应的值，如果<code>x</code>不存在，会报异常。</li><li><code>a.get(x)</code>：获取关键字<code>x</code>对应的值，如果<code>x</code>不存在，会返回<code>None</code>，不会报异常。</li><li><code>a.get(x, y)</code>：获取关键字<code>x</code>对应的值，如果<code>x</code>不存在，会返回默认值<code>y</code>，不会报异常。</li><li><code>a[x] = y</code>：在字典中插入一对元素，如果关键字<code>x</code>已存在，则将它之前映射的值覆盖掉。</li><li><code>del a[x]</code>：删除关键字<code>x</code>对应的元素对，如果<code>x</code>不存在，会报异常。</li><li><code>x in a</code>：检查字典中是否存在关键字<code>x</code>。</li><li><code>x not in a</code>：检查字典中是否不存在关键字<code>x</code>。</li><li><code>a.keys()</code>：返回字典的所有<code>key</code>。</li><li><code>a.values()</code>：返回字典的所有<code>value</code>。</li><li><code>a.items()</code>：返回字典的所有由<code>key</code>和<code>value</code>组成的元组。</li></ul><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;def&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;python&#x27;</span>: <span class="number">3</span>&#125;  <span class="comment"># 初始化一个字典</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 输出3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;def&#x27;</span>])  <span class="comment"># 输出2</span></span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;def&#x27;</span>))  <span class="comment"># 输出2</span></span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">5</span>))  <span class="comment"># 因为&#x27;xyz&#x27;不存在，所以输出默认值5</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;hello&#x27;</span>] = <span class="number">4</span>  <span class="comment"># 插入一对元素 &#x27;hello&#x27; -&gt; 4</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出&#123;&#x27;abc&#x27;: 1, &#x27;def&#x27;: 2, &#x27;python&#x27;: 3, &#x27;hello&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;def&#x27;</span>] = <span class="number">5</span>  <span class="comment"># 更新&#x27;def&#x27;映射的值</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;def&#x27;</span>])  <span class="comment"># 输出5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;python&#x27;</span>]  <span class="comment"># 删除关键字&#x27;python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出&#123;&#x27;abc&#x27;: 1, &#x27;def&#x27;: 5, &#x27;hello&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> a)  <span class="comment"># 输出True</span></span><br><span class="line"><span class="built_in">print</span>(a.keys())  <span class="comment"># 输出dict_keys([&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;hello&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(a.values())  <span class="comment"># 输出dict_values([1, 5, 4])</span></span><br><span class="line"><span class="built_in">print</span>(a.items())  <span class="comment"># 输出dict_items([(&#x27;abc&#x27;, 1), (&#x27;def&#x27;, 5), (&#x27;hello&#x27;, 4)])</span></span><br></pre></td></tr></table></figure><h4 id="3-3-使用for循环遍历字典"><a href="#3-3-使用for循环遍历字典" class="headerlink" title="3.3 使用for循环遍历字典"></a>3.3 使用<code>for</code>循环遍历字典</h4><p>类似于列表，字典也可以用<code>for ... in ...</code>的形式遍历。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;def&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;python&#x27;</span>: <span class="number">3</span>&#125;  <span class="comment"># 初始化一个字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> a:  <span class="comment"># 遍历key</span></span><br><span class="line">    <span class="built_in">print</span>(k, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> a.keys():  <span class="comment"># 遍历key</span></span><br><span class="line">    <span class="built_in">print</span>(k, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a.values():  <span class="comment"># 遍历value</span></span><br><span class="line">    <span class="built_in">print</span>(v, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> a.items():  <span class="comment"># 遍历key-value对</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s, %d) &quot;</span> % (k, v), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><h3 id="4-作业扩展"><a href="#4-作业扩展" class="headerlink" title="4. 作业扩展"></a>4. 作业扩展</h3><p><code>map()</code>也可以用<code>for ... in ...</code>的形式遍历。例如：<code>for x in map(int, input().split())</code>可以遍历一行内用空格隔开的每个整数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E5%85%83%E7%BB%84&quot;&gt;1. 元组&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-%E5%85%83%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96&quot;&gt;1.1 元组的初始化&lt;/</summary>
      
    
    
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串</title>
    <link href="https://zade23.github.io/2023/10/18/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://zade23.github.io/2023/10/18/Python%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-10-18T08:18:06.000Z</published>
    <updated>2024-03-21T02:04:55.828Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%95%B4%E6%95%B0%E7%9A%84%E8%81%94%E7%B3%BBascii%E7%A0%81">1. 字符与整数的联系——ASCII码</a></li><li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%86%99%E6%B3%95">2. 字符串常量的写法</a></li><li><a href="#3-%E8%A1%A8%E7%A4%BA%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89">3. 表示特殊字符——转义</a></li><li><a href="#4-%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6">4. 访问字符串中的每个字符</a></li><li><a href="#5-%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2">5. 使用循环语句遍历字符串</a></li><li><a href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C">6. 字符串的切片操作</a></li><li><a href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%8D%E5%88%B6">7. 字符串的复制</a></li><li><a href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BF%90%E7%AE%97">8. 字符串的运算</a></li><li><a href="#9-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">9. 字符串的常用操作</a></li><li><a href="#10-%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA">10. 更复杂的格式化输出</a></li><li><a href="#11-%E4%BD%9C%E4%B8%9A%E9%A2%98%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9">11. 作业题扩展内容</a></li></ul><hr><h3 id="1-字符与整数的联系——ASCII码"><a href="#1-字符与整数的联系——ASCII码" class="headerlink" title="1. 字符与整数的联系——ASCII码"></a>1. 字符与整数的联系——ASCII码</h3><p>每个常用字符都对应一个-128 ~ 127的数字，二者之间可以相互转化。注意：目前负数没有与之对应的字符。</p><ul><li><p>ord()函数可以求一个字符的ASCII码。注意输入是一个字符，而不是字符串。</p></li><li><p>chr()函数可以将一个ASCII码转化成对应的字符。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(c))</span><br><span class="line"></span><br><span class="line">a = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(a))</span><br></pre></td></tr></table></figure><p>常用ASCII值：<code>&#39;A&#39;- &#39;Z&#39;</code>是<code>65 ~ 90</code>，<code>&#39;a&#39; - &#39;z&#39;</code>是<code>97 - 122</code>，<code>0 - 9</code>是<code>48 - 57</code>。</p><p><strong>注意</strong>：虽然字符可以跟整数相互转化，但在Python中，字符不能参与数值运算，这一点跟C++、Java等语言是不同的。</p><hr><h3 id="2-字符串常量的写法"><a href="#2-字符串常量的写法" class="headerlink" title="2. 字符串常量的写法"></a>2. 字符串常量的写法</h3><p>在Python中，字符串既可以用单引号来表示，也可以用双引号来表示，二者完全相同。<br>这一点跟C++、Java等编程语言是不同的，在这些编程语言中，用单引号来表示字符，用双引号来表示字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;Hello World&quot;</span>  <span class="comment"># 双引号写法</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b = <span class="string">&#x27;Hello World&#x27;</span>  <span class="comment"># 单引号写法</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>两个或多个字符串常量并排写，会被自动合并，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;My &quot;</span> <span class="string">&quot;name &quot;</span> <span class="string">&quot;is yxc.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出：My name is yxc.</span></span><br></pre></td></tr></table></figure><p>一个字符串如果包含多行，可以采用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的初始化方式，字符串中将自动包含回车字符，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;&quot;&quot;Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">     -h                        Display this usage message</span></span><br><span class="line"><span class="string">     -H hostname               Hostname to connect to&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>会得到如下输出：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname               Hostname to connect to</span><br></pre></td></tr></table></figure><h3 id="3-表示特殊字符——转义"><a href="#3-表示特殊字符——转义" class="headerlink" title="3. 表示特殊字符——转义"></a>3. 表示特殊字符——转义</h3><p>当想在字符串中表示特殊字符时，一般可以在字符前加反斜杠<code>\</code>。</p><p>常见需要转义的字符有：</p><table><thead><tr><th>转义字符</th><th>含义</th><th>ASCII码（十进制）</th></tr></thead><tbody><tr><td><code>\n</code></td><td>回车</td><td>10</td></tr><tr><td>``</td><td>代表一个反斜杠<code>\</code></td><td>92</td></tr><tr><td>`“&#96;</td><td>表示一个双引号</td><td>34</td></tr><tr><td>`‘&#96;</td><td>表示一个单引号</td><td>39</td></tr></tbody></table><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is:\n\&quot;yxc!\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>会得到如下输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span>:</span><br><span class="line"><span class="string">&quot;yxc!&quot;</span></span><br></pre></td></tr></table></figure><p>另外，如果想输出单引号，也可以用双引号来表示，反之亦然。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#x27;yxc!&#x27;&quot;</span>)  <span class="comment"># 输出：My name is &#x27;yxc!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My name is &quot;yxc!&quot;&#x27;</span>)  <span class="comment"># 输出：My name is &quot;yxc!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-访问字符串中的每个字符"><a href="#4-访问字符串中的每个字符" class="headerlink" title="4. 访问字符串中的每个字符"></a>4. 访问字符串中的每个字符</h3><p>可以通过下标读取字符串中的每个字符，下标从0开始，也可以是负数，负数下标表示的是除以字符串长度的余数对应的位置。</p><p>负数下标相当于将字符串首位相接，然后从0往前数。</p><p>如果字符串长度是 nn，那么下标只能取 −n∼n−1−n∼n−1 之间的整数，超出范围会报错。</p><p><strong>注意</strong>：字符串中的每个字符不能修改。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], <span class="built_in">ord</span>(a[<span class="number">5</span>]))  <span class="comment"># 输出H 32</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span>  <span class="comment"># 会报错，字符串不能修改</span></span><br></pre></td></tr></table></figure><h3 id="5-使用循环语句遍历字符串"><a href="#5-使用循环语句遍历字符串" class="headerlink" title="5. 使用循环语句遍历字符串"></a>5. 使用循环语句遍历字符串</h3><p>可以通过下标访问，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;acwing&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(s[i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><p>可以通过<code>for ... in ...</code>直接遍历，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;python&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(c, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 注意c本身也是字符串类型</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><h3 id="6-字符串的切片操作"><a href="#6-字符串的切片操作" class="headerlink" title="6. 字符串的切片操作"></a>6. 字符串的切片操作</h3><p>字符串的切片操作会返回一个新字符串。用法：</p><ul><li><code>a[begin:end]</code> 会返回包含<code>a[begin], a[begin + 1], ..., a[end - 1]</code>的字符串。</li><li>省略<code>begin</code>时，<code>begin</code>的默认值是0。</li><li>省略<code>end</code>时，<code>end</code>的默认值是字符串长度。</li><li>如果<code>begin</code>或<code>end</code>是负数，表示的是除以字符串长度后的余数。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 输出BCD</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])  <span class="comment"># 输出BCDE</span></span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">4</span>])  <span class="comment"># 输出ABCD</span></span><br><span class="line"><span class="built_in">print</span>(a[:])  <span class="comment"># 输出ABCDE</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">4</span>:-<span class="number">1</span>])  <span class="comment"># 等价于print(a[1:4])</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：字符串的切片不支持写操作。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = <span class="string">&quot;XY&quot;</span>  <span class="comment"># 会报错，字符串不能修改</span></span><br></pre></td></tr></table></figure><h3 id="7-字符串的复制"><a href="#7-字符串的复制" class="headerlink" title="7. 字符串的复制"></a>7. 字符串的复制</h3><p>跟列表不同，字符串的每次复制操作，都会得到一个全新的字符串。</p><h3 id="8-字符串的运算"><a href="#8-字符串的运算" class="headerlink" title="8. 字符串的运算"></a>8. 字符串的运算</h3><ul><li>字符串的加法可以将两个字符串拼接起来，得到一个新字符串。</li><li>字符串乘以一个整数，可以将若干个自身拼接起来，得到一个新字符串。</li><li>字符串支持比较运算符，按字典序比较大小。即如果两个字符串相同，则表示相等；否则找到两个字符串从左到右数第一个不一样的字符，哪个字符串的字符的ASCII码小，哪个字符串的字典序就小；另外空字符比任何字符都小。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;Hello &quot;</span></span><br><span class="line">b = <span class="string">&quot;World&quot;</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出Hello World</span></span><br><span class="line"></span><br><span class="line">d = a * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出Hello Hello Hello</span></span><br><span class="line"></span><br><span class="line">e = a * <span class="number">3</span> + <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(e)  <span class="comment"># 输出Hello Hello Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &lt;= b)  <span class="comment"># 按字典序比较大小，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span> &gt; <span class="string">&quot;22&quot;</span>)  <span class="comment"># 按字典序比较大小，输出False</span></span><br></pre></td></tr></table></figure><h3 id="9-字符串的常用操作"><a href="#9-字符串的常用操作" class="headerlink" title="9. 字符串的常用操作"></a>9. 字符串的常用操作</h3><p>假设<code>s</code>是一个字符串，则：</p><ul><li><p><code>len(s)</code>返回字符串长度。</p></li><li><p><code>s.split(sep)</code>返回一个字符串列表。如果给出了<code>sep</code>就按<code>sep</code>分隔；如果没给出，则会按空格分隔，但连续的空格会被视为单个分隔符，而且会忽略首尾的空白字符。</p></li><li><p><code>s.strip()</code>将首尾的空白字符删除。</p></li><li><p><code>s.replace(old, new)</code>将<code>s</code>中所有的<code>old</code>子串都改成<code>new</code>。</p></li><li><p><code>s.find(&quot;abc&quot;)</code>查询某个子串在<code>s</code>中第一次出现的下标；如果不存在，则返回-1。</p></li><li><p><code>s.startswith(prefix)</code>判断<code>prefix</code>是否为<code>s</code>的前缀。</p></li><li><p><code>s.endswith(suffix)</code>判断<code>suffix</code>是否为<code>s</code>的后缀。</p></li><li><p><code>s.lower()</code>将所有大写字母变成小写。</p></li><li><p><code>s.upper()</code>将所有小写字母变成大写。</p></li><li><p><code>s.join(a)</code>，<code>a</code>是一个字符串列表，这个函数返回将a中的字符用<code>s</code>作为分隔符拼接起来的结果。</p></li></ul><p><strong>注意</strong>：返回的所有字符串都是新字符串，原字符串不变。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;abc def xyz&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s1))  <span class="comment"># 输出11</span></span><br><span class="line"><span class="built_in">print</span>(s1.split())  <span class="comment"># 输出[&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;xyz&#x27;]</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">&quot;  abc abc  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s2.strip())  <span class="comment"># 输出abc abc</span></span><br><span class="line"><span class="built_in">print</span>(s2.replace(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;*&quot;</span>))  <span class="comment"># 输出  * *</span></span><br><span class="line"><span class="built_in">print</span>(s2.find(<span class="string">&quot;abc&quot;</span>), s2.find(<span class="string">&quot;xyz&quot;</span>))  <span class="comment"># 输出2 -1</span></span><br><span class="line"></span><br><span class="line">s3 = <span class="string">&quot;Abc deF&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s3.startswith(<span class="string">&quot;Ab&quot;</span>))  <span class="comment"># 输出True</span></span><br><span class="line"><span class="built_in">print</span>(s3.endswith(<span class="string">&quot;deF&quot;</span>))  <span class="comment"># 输出True</span></span><br><span class="line"><span class="built_in">print</span>(s3.lower())  <span class="comment"># 输出abc def</span></span><br><span class="line"><span class="built_in">print</span>(s3.upper())  <span class="comment"># 输出ABC DEF</span></span><br><span class="line"></span><br><span class="line">s4 = <span class="string">&quot;, &quot;</span></span><br><span class="line">a = [<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(s4.join(a))  <span class="comment"># 输出aa, bb, cc</span></span><br></pre></td></tr></table></figure><h3 id="10-更复杂的格式化输出"><a href="#10-更复杂的格式化输出" class="headerlink" title="10. 更复杂的格式化输出"></a>10. 更复杂的格式化输出</h3><p>当需要用到更复杂的格式化输出时，现查即可。可以参考：</p><ul><li><a href="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#formatted-string-literals">更复杂的输出格式</a></li><li><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting">printf 风格的字符串格式化</a></li></ul><h3 id="11-作业题扩展内容"><a href="#11-作业题扩展内容" class="headerlink" title="11. 作业题扩展内容"></a>11. 作业题扩展内容</h3><ol><li>作业的评测器会自动忽略每一行的行末空格，所以行末输出多余空格也视为正确。</li><li><code>s.isdigit()</code>：当字符串<code>s</code>不是空字符串，且包含的所有字符都是数字时返回True，否则返回False。</li><li><code>a, b = [&quot;abc&quot;, &quot;def&quot;]</code>这种写法可以将<code>&quot;abc&quot;</code>赋值给第一个变量<code>a</code>，将<code>&quot;def&quot;</code>赋值给第二个变量<code>b</code>。</li><li><code>s.rfind(&quot;abc&quot;)</code>查询某个子串在<code>s</code>中最后一次出现的下标；如果不存在，则返回-1。</li><li>当不知道读入的具体行数时，可以采用如下方法一次性读取所有行：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdin.readlines():</span><br><span class="line">    <span class="built_in">print</span>(line.strip())  <span class="comment"># strip()是为了去掉行末的回车</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%95%B4%E6%95%B0%E7%9A%84%E8%81%94%E7%B3%BBascii%E7%A0%81&quot;&gt;1. 字符与整数的联系——ASCII码&lt;/a&gt;&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>经济学——流动性陷阱</title>
    <link href="https://zade23.github.io/2023/10/16/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E2%80%94%E2%80%94%E6%B5%81%E5%8A%A8%E6%80%A7%E9%99%B7%E9%98%B1/"/>
    <id>https://zade23.github.io/2023/10/16/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E2%80%94%E2%80%94%E6%B5%81%E5%8A%A8%E6%80%A7%E9%99%B7%E9%98%B1/</id>
    <published>2023-10-16T02:37:26.000Z</published>
    <updated>2024-03-21T06:37:38.879Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E6%B5%81%E5%8A%A8%E6%80%A7%E9%99%B7%E9%98%B1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">流动性陷阱——名词解释</a><ul><li><a href="#%E7%99%BD%E8%AF%9D%E8%A7%A3%E9%87%8A">白话解释</a></li><li><a href="#%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E8%A7%A3%E9%87%8A">维基百科解释</a></li></ul></li><li><a href="#%E6%8D%A2%E4%B8%AA%E8%A7%86%E8%A7%92%E7%9C%8B%E9%97%AE%E9%A2%98">换个视角看问题</a><ul><li><a href="#%E5%9B%BD%E5%AE%B6%E5%B1%82%E9%9D%A2">国家层面</a></li><li><a href="#%E4%BA%BA%E6%B0%91%E5%B1%82%E9%9D%A2">人民层面</a></li></ul></li></ul><hr><h2 id="流动性陷阱——名词解释"><a href="#流动性陷阱——名词解释" class="headerlink" title="流动性陷阱——名词解释"></a>流动性陷阱——名词解释</h2><h3 id="白话解释"><a href="#白话解释" class="headerlink" title="白话解释"></a>白话解释</h3><p><strong>流动性陷阱</strong>是一个经济学概念，出现在名义利率已经接近零或非常低，而央行进一步减少利率仍然不能刺激投资和消费的情况。在这种情境下，货币政策的传统工具，如购买国债以增加货币供应量，可能变得无效，因为商业银行和公众可能选择持有现金而不是投资或消费。这是因为他们预期未来的回报率很低，或对未来经济有所担忧。</p><h3 id="维基百科解释"><a href="#维基百科解释" class="headerlink" title="维基百科解释"></a><a href="https://zh.wikipedia.org/zh-hans/%E6%B5%81%E5%8B%95%E6%80%A7%E9%99%B7%E9%98%B1">维基百科解释</a></h3><p><strong>流动性陷阱</strong>（英语：liquidity trap），是<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B">英国</a><a href="https://zh.wikipedia.org/wiki/%E7%B6%93%E6%BF%9F%E5%AD%B8%E5%AE%B6">经济学家</a><a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E6%A2%85%E7%BA%B3%E5%BE%B7%C2%B7%E5%87%AF%E6%81%A9%E6%96%AF">凯恩斯</a>提出的概念，又称<strong>凯恩斯陷阱</strong>。</p><p>在<a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E6%81%A9%E6%96%AF%E4%B8%BB%E7%BE%A9">凯恩斯主义</a>经济学中，流动性陷阱是指一个当<a href="https://zh.wikipedia.org/wiki/%E8%B2%A8%E5%B9%A3%E6%94%BF%E7%AD%96">货币政策</a>完全没法刺激经济的情况，无论降低<a href="https://zh.wikipedia.org/wiki/%E5%88%A9%E7%8E%87">利率</a>抑或增加<a href="https://zh.wikipedia.org/wiki/%E8%B2%A8%E5%B9%A3%E4%BE%9B%E6%87%89%E9%87%8F">货币供应量</a>也没有作用。典型的<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8B%95%E6%80%A7">流动性</a>陷阱在当预期<a href="https://zh.wikipedia.org/wiki/%E7%BB%8F%E6%B5%8E%E8%A1%B0%E9%80%80">经济不景气</a>出现（例如<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%B2%A8%E7%B7%8A%E7%B8%AE">通货紧缩</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B8%BD%E9%9C%80%E6%B1%82">总需求</a>不足、发生战争），使持有<a href="https://zh.wikipedia.org/wiki/%E5%B8%82%E5%A0%B4%E6%B5%81%E9%80%9A%E6%80%A7">流动资产</a>的人不愿意<a href="https://zh.wikipedia.org/wiki/%E6%8A%95%E8%B3%87">投资</a>。</p><h2 id="换个视角看问题"><a href="#换个视角看问题" class="headerlink" title="换个视角看问题"></a>换个视角看问题</h2><blockquote><p>GPT4的回答</p></blockquote><h3 id="国家层面"><a href="#国家层面" class="headerlink" title="国家层面"></a>国家层面</h3><p>站在<strong>国家</strong>的角度：</p><ol><li><strong>财政政策</strong>：当货币政策变得无效时，国家可以使用财政政策，如增加公共支出、减税或直接向家庭提供资金，以刺激经济。</li><li><strong>结构性改革</strong>：国家可以采取长期的结构性改革，如改善教育、健康、基础设施，以增加生产力和潜在产出。</li><li><strong>消除不确定性</strong>：政府可以采取措施减少经济中的不确定性，这可能包括提供更清晰的经济前景、稳定的政策环境等。</li><li><strong>合作</strong>：与其他国家合作，通过国际贸易和投资来促进增长。</li></ol><h3 id="人民层面"><a href="#人民层面" class="headerlink" title="人民层面"></a>人民层面</h3><p>站在<strong>人民</strong>的角度：</p><ol><li><strong>储蓄与投资</strong>：在经济不确定性和低回报期望的背景下，人们可能会倾向于增加储蓄。然而，他们也应考虑多样化投资，可能在国外或不同的资产类别，以获得更好的回报。</li><li><strong>消费</strong>：尽管流动性陷阱可能导致对未来的担忧，但是长时间的压抑消费可能进一步伤害经济。如果有能力，人民可以考虑适度的消费。</li><li><strong>教育与技能提升</strong>：在经济低迷的时期，提高自己的技能和教育背景可以帮助人们为未来更好的机会做好准备。</li><li><strong>避免过度债务</strong>：在低利率环境下，尽管贷款更便宜，但人们应避免过度债务，以确保在经济形势变化时能够应对。</li></ol><p>总之，流动性陷阱是一个复杂的经济问题，需要多方面的策略来应对。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B5%81%E5%8A%A8%E6%80%A7%E9%99%B7%E9%98%B1%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A&quot;&gt;流动性陷阱——名词解释&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%</summary>
      
    
    
    
    <category term="杂项" scheme="https://zade23.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="经济学小知识" scheme="https://zade23.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Python函数</title>
    <link href="https://zade23.github.io/2023/10/12/Python%E5%87%BD%E6%95%B0/"/>
    <id>https://zade23.github.io/2023/10/12/Python%E5%87%BD%E6%95%B0/</id>
    <published>2023-10-12T10:22:54.000Z</published>
    <updated>2024-03-14T02:59:41.168Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80">1. 函数基础</a><ul><li><a href="#11-%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0">1.1 编写函数</a></li><li><a href="#12-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">1.2 调用函数</a></li><li><a href="#13-%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82">1.3 形参和实参</a><ul><li><a href="#131-%E5%BD%A2%E5%8F%82%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F">1.3.1 形参的初始化方式</a></li><li><a href="#132-%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%BD%A2%E5%8F%82">1.3.2 带默认值的形参</a></li><li><a href="#133-%E5%85%B6%E5%AE%83%E5%8F%82%E6%95%B0%E5%86%99%E6%B3%95">1.3.3 其它参数写法</a></li></ul></li><li><a href="#14-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">1.4 变量的作用域</a></li></ul></li><li><a href="#2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">2. 参数传递</a><ul><li><a href="#21-%E5%80%BC%E4%BC%A0%E9%80%92">2.1 值传递</a></li><li><a href="#22-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">2.2 引用传递</a></li></ul></li><li><a href="#3return%E8%AF%AD%E5%8F%A5">3.<code>return</code>语句</a></li><li><a href="#4lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.<code>lambda</code>表达式</a></li><li><a href="#5-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92">5. 函数递归</a></li></ul><hr><p>Python中函数的用法非常多，<u><strong>80%的用法不常用，20%的用法常用</strong></u>。大家不要把精力浪费在背完所有用法上，而要把主要精力放到最常用的20%的用法和代码逻辑上，至于另外80%不常用的用法，边用边查就行。</p><h3 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1. 函数基础"></a>1. 函数基础</h3><p>Python中一个典型的函数定义包括以下部分：关键字<code>def</code>、函数名称、由0个或多个形参组成的列表以及函数体。</p><h4 id="1-1-编写函数"><a href="#1-1-编写函数" class="headerlink" title="1.1 编写函数"></a>1.1 编写函数</h4><p>我们来编写一个求阶乘的函数。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        res *= i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>函数名称是<code>fact</code>，给它传入一个<code>n</code>，会返回<code>n</code>的阶乘。<code>return</code>语句负责结束函数并返回<code>res</code>的值。</p><h4 id="1-2-调用函数"><a href="#1-2-调用函数" class="headerlink" title="1.2 调用函数"></a>1.2 调用函数</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我们要计算5的阶乘，答案是：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fact(<span class="number">5</span>))  <span class="comment"># 输出 120</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算结束啦！&quot;</span>)</span><br></pre></td></tr></table></figure><p>函数的调用完成两项工作：</p><ul><li>用实参初始化函数对应的形参</li><li>将控制权转移给被调用的函数</li></ul><p>此时，代码原本的执行顺序被暂时中断，被调函数开始执行。等被调用函数执行完后，再继续执行之前的代码。</p><h4 id="1-3-形参和实参"><a href="#1-3-形参和实参" class="headerlink" title="1.3 形参和实参"></a>1.3 形参和实参</h4><p>实参指调用函数时传入的变量或常量，形参指定义函数时参数列表里的变量。</p><p>形参列表可以为空，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">f()  <span class="comment"># 输出 Hello World</span></span><br></pre></td></tr></table></figure><h5 id="1-3-1-形参的初始化方式"><a href="#1-3-1-形参的初始化方式" class="headerlink" title="1.3.1 形参的初始化方式"></a>1.3.1 形参的初始化方式</h5><p>调用函数时会用实参去初始化形参，初始化的顺序有两种：</p><p>第一种是用位置实参来初始化形参。顾名思义，实参会按位置关系来初始化形参，第一个实参初始化第一个形参，第二个实参初始化第二个形参，依此类推。形参和实参的个数必须匹配。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c, d</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">True</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">4.2</span>)  <span class="comment"># 输出 a = 1, b = True, c = Python, d = 4.2</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">True</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">4.2</span>, <span class="number">3</span>)  <span class="comment"># 会报错，因为实参个数多于形参</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">True</span>, <span class="string">&quot;Python&quot;</span>)  <span class="comment"># 会报错，因为实参个数少于形参</span></span><br></pre></td></tr></table></figure><p>第二种是用关键字实参来初始化形参。此时实参不再按位置关系来初始化形参，而是按变量名初始化。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f()的定义如上所述</span></span><br><span class="line">f(b=<span class="number">1</span>, c=<span class="literal">True</span>, a=<span class="string">&quot;Python&quot;</span>, d=<span class="number">4.2</span>)  <span class="comment"># 输出 a = Python, b = 1, c = True, d = 4.2</span></span><br></pre></td></tr></table></figure><p>两种方式也可以混合使用，但是位置实参一定要放到关键字实参之前。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f()的定义如上所述</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, d=<span class="string">&quot;Python&quot;</span>, c=<span class="number">4.2</span>)  <span class="comment"># 输出 a = 1, b = 2, c = 4.2, d = Python</span></span><br><span class="line">f(<span class="number">1</span>, b=<span class="number">3</span>, <span class="string">&quot;Python&quot;</span>, d=<span class="number">4.2</span>)  <span class="comment"># 会报错，因为位置实参位于关键字实参后面了。</span></span><br></pre></td></tr></table></figure><h5 id="1-3-2-带默认值的形参"><a href="#1-3-2-带默认值的形参" class="headerlink" title="1.3.2 带默认值的形参"></a>1.3.2 带默认值的形参</h5><p>形参也可以设置默认值，但所有带默认值的形参必须是最后几个。当某些形参没有被初始化时，这些形参会使用默认值。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c=<span class="number">3</span>, d=<span class="string">&quot;Python&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># c和d没有被初始化，采用默认值。输出 a = 1, b = 2, c = 3, d = Python</span></span><br><span class="line">f(<span class="number">1</span>, b=<span class="number">2</span>, d=<span class="string">&quot;AcWing&quot;</span>)  <span class="comment"># c没有被初始化，采用默认值。输出 a = 1, b = 2, c = 3, d = AcWing</span></span><br></pre></td></tr></table></figure><h5 id="1-3-3-其它参数写法"><a href="#1-3-3-其它参数写法" class="headerlink" title="1.3.3 其它参数写法"></a>1.3.3 其它参数写法</h5><p>其它参数写法用得不多，想了解的同学可以参考<a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#more-on-defining-functions">函数定义详解</a>。</p><h4 id="1-4-变量的作用域"><a href="#1-4-变量的作用域" class="headerlink" title="1.4 变量的作用域"></a>1.4 变量的作用域</h4><p>函数内定义的变量为局部变量，只能在函数内部使用。</p><p>当需要修改用全局变量时，需要用<code>global</code>关键字在函数内声明全局变量。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">global</span> x  <span class="comment"># 在函数内声明全局变量</span></span><br><span class="line">    x = <span class="number">666</span></span><br><span class="line">    y = <span class="number">777</span></span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f()  <span class="comment"># 输出 666 777</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 会发现全局变量x也被修改了</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 会报错，因为y是局部变量，函数外无法使用</span></span><br></pre></td></tr></table></figure><p>1.5 嵌套定义函数<br>函数内部也可以定义函数。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):  <span class="comment"># 定义函数g()</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    g(<span class="number">5</span>)  <span class="comment"># 调用函数g()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f()  <span class="comment"># 输出6</span></span><br></pre></td></tr></table></figure><p>1.6 <code>pass</code>语句<br>当函数定义完但还不想实现时，可以用<code>pass</code>占位符，来避免出现语法错误。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. 参数传递</h3><h4 id="2-1-值传递"><a href="#2-1-值传递" class="headerlink" title="2.1 值传递"></a>2.1 值传递</h4><p><code>int</code>、<code>float</code>、<code>bool</code>、字符串等采用值传递。</p><p>将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">y</span>):</span><br><span class="line">    y = <span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">f(x)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 会发现x的值没变</span></span><br></pre></td></tr></table></figure><h4 id="2-2-引用传递"><a href="#2-2-引用传递" class="headerlink" title="2.2 引用传递"></a>2.2 引用传递</h4><p>列表采用引用传递。</p><p>将实参的引用传给形参，此时对形参的修改会影响实参的初始值。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        b[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">f(a)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 会发现列表a中的每个数加了1</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-return语句"><a href="#3-return语句" class="headerlink" title="3.return语句"></a>3.<code>return</code>语句</h3><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方，并返回结果。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 不写返回值时，会返回None</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>  <span class="comment"># 返回一个变量</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>, <span class="number">5</span>  <span class="comment"># 返回多个变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = f(<span class="number">1</span>)</span><br><span class="line">b = f(<span class="number">2</span>)</span><br><span class="line">c, d = f(<span class="number">3</span>)</span><br><span class="line">e = f(<span class="number">4</span>)  <span class="comment"># 没写return时，也会返回None</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e)  <span class="comment"># 输出 None 3 4 5 None</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-lambda表达式"><a href="#4-lambda表达式" class="headerlink" title="4.lambda表达式"></a>4.<code>lambda</code>表达式</h3><p>lambda关键字可以创建匿名函数，目的是为了简化代码。可以对比下面两种写法，会发现lambda表达式的写法更短一些。</p><p>常与sort()函数配合使用，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pairs = [[<span class="number">1</span>, <span class="string">&quot;one&quot;</span>], [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>], [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>], [<span class="number">4</span>, <span class="string">&quot;four&quot;</span>]]</span><br><span class="line"></span><br><span class="line">pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])  <span class="comment"># 每个元素使用第二个变量比较大小</span></span><br><span class="line"><span class="built_in">print</span>(pairs)  <span class="comment"># 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]]</span></span><br></pre></td></tr></table></figure><p>等价于下面的写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pairs = [[<span class="number">1</span>, <span class="string">&quot;one&quot;</span>], [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>], [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>], [<span class="number">4</span>, <span class="string">&quot;four&quot;</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">pair</span>):</span><br><span class="line">    <span class="keyword">return</span> pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pairs.sort(key=compare)  <span class="comment"># 每个元素使用第二个变量比较大小</span></span><br><span class="line"><span class="built_in">print</span>(pairs)  <span class="comment"># 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]]</span></span><br></pre></td></tr></table></figure><h3 id="5-函数递归"><a href="#5-函数递归" class="headerlink" title="5. 函数递归"></a>5. 函数递归</h3><p>在一个函数内部，也可以调用函数自身。这种写法被称为递归。</p><p>写递归函数可以从集合的角度来思考。理解递归函数的执行顺序可以用树的形式来思考。</p><p>例如，求解斐波那契数列第 nn 项可以采用如下写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fib(<span class="number">6</span>))  <span class="comment"># 输出 8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80&quot;&gt;1. 函数基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0&quot;&gt;1.1 编写函数&lt;/</summary>
      
    
    
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>github_workflow自动合并主线失败问题</title>
    <link href="https://zade23.github.io/2023/10/08/githun-workflow%E8%87%AA%E5%8A%A8%E5%90%88%E5%B9%B6%E4%B8%BB%E7%BA%BF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://zade23.github.io/2023/10/08/githun-workflow%E8%87%AA%E5%8A%A8%E5%90%88%E5%B9%B6%E4%B8%BB%E7%BA%BF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-08T02:16:53.000Z</published>
    <updated>2023-10-08T02:37:06.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github-workflow自动提交在合并主线时出现的问题"><a href="#github-workflow自动提交在合并主线时出现的问题" class="headerlink" title="github_workflow自动提交在合并主线时出现的问题"></a>github_workflow自动提交在合并主线时出现的问题</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>看到 GitHub 上的一个好玩的项目，大意就是保持个人主页的提交栏保持尝绿，看起来很有意思，于是学着构建了一个 GitHub_actions_workflow 。仓库是用来每日清晨推送 bing 的当日壁纸的，仓库为：<a href="https://github.com/zade23/auto-green">https://github.com/zade23/auto-green</a></p><p>但是部署之后发现 Actions 的 <em>合并提交</em> 动作一直失败，报错如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">remote:</span> <span class="string">Permission</span> <span class="string">to</span> <span class="string">zade23/auto-green.git</span> <span class="string">denied</span> <span class="string">to</span> <span class="string">github-actions[bot].</span></span><br><span class="line"><span class="attr">fatal:</span> <span class="string">unable</span> <span class="string">to</span> <span class="string">access</span> <span class="attr">&#x27;https://github.com/zade23/auto-green.git/&#x27;:</span> <span class="attr">The requested URL returned error:</span> <span class="number">403</span></span><br><span class="line"><span class="attr">Error: Invalid exit code:</span> <span class="number">128</span></span><br><span class="line">    <span class="string">at</span> <span class="string">ChildProcess.&lt;anonymous&gt;</span> <span class="string">(/home/runner/work/_actions/ad-m/github-push-action/master/start.js:30:21)</span></span><br><span class="line">    <span class="string">at</span> <span class="string">ChildProcess.emit</span> <span class="string">(node:events:513:28)</span></span><br><span class="line">    <span class="string">at</span> <span class="string">maybeClose</span> <span class="string">(node:internal/child_process:1100:16)</span></span><br><span class="line">    <span class="string">at</span> <span class="string">Process.ChildProcess._handle.onexit</span> <span class="string">(node:internal/child_process:304:5)</span> &#123;</span><br><span class="line">  <span class="attr">code:</span> <span class="number">128</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>分析主要问题，应试这段 <code>The requested URL returned error: 403</code> 。</p><p>最终在 Stack Overflow 上找到了解决办法：</p><p><a href="https://stackoverflow.com/questions/73687176/permission-denied-to-github-actionsbot-the-requested-url-returned-error-403">Permission denied to github-actions[bot]. The requested URL returned error: 403</a></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>GitHub Actions 中自动提交功能必须在对应仓库下面手动设置允许 bot 合并提交的权限，否则合并动作就会被拒绝。</p><p>启动 actions 的 repository - Settings -&gt; Action -&gt; General -&gt; Workflow permissions</p><p><a href="https://imgse.com/i/pPvpqqe"><img src="https://z1.ax1x.com/2023/10/08/pPvpqqe.jpg" alt="操作流程"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;github-workflow自动提交在合并主线时出现的问题&quot;&gt;&lt;a href=&quot;#github-workflow自动提交在合并主线时出现的问题&quot; class=&quot;headerlink&quot; title=&quot;github_workflow自动提交在合并主线时出现的问题&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python数据结构和算法</title>
    <link href="https://zade23.github.io/2023/07/18/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://zade23.github.io/2023/07/18/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</id>
    <published>2023-07-18T07:12:00.000Z</published>
    <updated>2024-03-14T02:58:36.019Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3">算法分析相关</a><ul><li><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97">复杂度计算</a><ul><li><a href="#%E5%A4%A7-o-%E8%A1%A8%E7%A4%BA%E6%B3%95">大 <code>O</code> 表示法</a></li></ul></li></ul></li></ul><p><strong>类</strong> 都是对数据的构成（状态）以及数据能做什么（行为）的描述。<br>由于类的使用者只能看到数据项的状态和行为，因此类与抽象数据类型是相似的、</p><p>在面向对象编程范式中，数据项被称作 <strong>对象</strong> 一个对象就是类的一个实例。</p><p>1.内建原子数据结构<br>    python是通过两种内建数据类型实现整数类型和浮点数类型的，相应的python类就是 <code>int</code> 和 <code>float</code> 。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>列表</strong> 是零个或多个指向 Python 数据对象的引用的有序集合，通过在方括号内以逗号分隔的一系列值来表达。空列表就是 <code>[]</code>。列表是异构的，这意味着其指向的数据对象不需要都是同一个类，并且这一集合可以被赋值给一个变量。下面的代码段展示了列表含有多个不同的 Python 数据对象。</p><p><strong>元组</strong> 通常写成由括号包含并且以逗号分隔的一系列值。与序列一样，元组允许之前描述的任一操作。</p><h4 id="列表提供的方法"><a href="#列表提供的方法" class="headerlink" title="列表提供的方法"></a>列表提供的方法</h4><table><thead><tr><th>方法名</th><th>用法</th><th>解释</th></tr></thead><tbody><tr><td><code>append</code></td><td><code>alist.append(item)</code></td><td>在列表末尾添加一个新元素</td></tr><tr><td><code>insert</code></td><td><code>alist.insert(i,item)</code></td><td>在列表的第! <code>i</code> 个位置插入一个元素</td></tr><tr><td><code>pop</code></td><td><code>alist.pop()</code></td><td>删除并返回列表中最后一个元素</td></tr><tr><td><code>pop</code></td><td><code>alist.pop(i)</code></td><td>删除并返回列表中第 <code>i</code> 个位置的元素</td></tr><tr><td><code>sort</code></td><td><code>alist.sort()</code></td><td>将列表元素排序</td></tr><tr><td><code>reverse</code></td><td><code>alist.reverse()</code></td><td>将列表元素倒序排列</td></tr><tr><td><code>del</code></td><td><code>del alist[i]</code></td><td>删除列表中第 <code>i</code> 个位置的元素</td></tr><tr><td><code>index</code></td><td><code>alist.index(item)</code></td><td>返回 <code>item</code> 第一次出现时的下标</td></tr><tr><td><code>count</code></td><td><code>alist.count(item)</code></td><td>返回 <code>item</code> 在列表中出现的次数</td></tr><tr><td><code>remove</code></td><td><code>alist.remove(item)</code></td><td>从列表中移除第一次出现的 <code>item</code></td></tr></tbody></table><p>对应输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">3</span>, <span class="literal">True</span>, <span class="number">6.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.append(<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">3</span>, <span class="literal">True</span>, <span class="number">6.5</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.insert(<span class="number">2</span>,<span class="number">4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">3</span>, <span class="number">4.5</span>, <span class="literal">True</span>, <span class="number">6.5</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.pop()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">3</span>, <span class="number">4.5</span>, <span class="literal">True</span>, <span class="number">6.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.pop(<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">4.5</span>, <span class="literal">True</span>, <span class="number">6.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.pop(<span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">4.5</span>, <span class="number">6.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">4.5</span>, <span class="number">6.5</span>, <span class="number">1024</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">6.5</span>, <span class="number">4.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.count(<span class="number">6.5</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.index(<span class="number">4.5</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList.remove(<span class="number">6.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">1024</span>, <span class="number">4.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> myList[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myList</span><br><span class="line">[<span class="number">4.5</span>]</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是零个或多个字母、数字和其他符号的有序集合。这些字母、数字和其他符号被称为 <em>字符</em>。常量字符串值通过引号（单引号或者双引号均可）与标识符进行区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;David&quot;</span></span><br><span class="line"><span class="string">&#x27;David&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myName = <span class="string">&quot;David&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myName[<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;i&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myName*<span class="number">2</span></span><br><span class="line"><span class="string">&#x27;DavidDavid&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(myName)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="字符串提供的方法"><a href="#字符串提供的方法" class="headerlink" title="字符串提供的方法"></a>字符串提供的方法</h4><table><thead><tr><th>方法名</th><th>用法</th><th>解释</th></tr></thead><tbody><tr><td><code>center</code></td><td><code>astring.center(w)</code></td><td>返回一个字符串，原字符串居中，使用空格填充新字符串，使其长度为 <code>w</code></td></tr><tr><td><code>count</code></td><td><code>astring.count(item)</code></td><td>返回 <code>item</code> 出现的次数</td></tr><tr><td><code>ljust</code></td><td><code>astring.ljust(w)</code></td><td>返回一个字符串，将原字符串靠左放置并填充空格至长度 <code>w</code></td></tr><tr><td><code>rjust</code></td><td><code>astring.rjust(w)</code></td><td>返回一个字符串，将原字符串靠右放置并填充空格至长度 <code>w</code></td></tr><tr><td><code>lower</code></td><td><code>astring.lower()</code></td><td>返回均为小写字母的字符串</td></tr><tr><td><code>upper</code></td><td><code>astring.upper()</code></td><td>返回均为大写字母的字符串</td></tr><tr><td><code>find</code></td><td><code>astring.find(item)</code></td><td>返回 <code>item</code> 第一次出现时的下标</td></tr><tr><td><code>split</code></td><td><code>astring.split(schar)</code></td><td>在 <code>schar</code> 位置将字符串分割成子串，不填则默认分割空格和换行符</td></tr></tbody></table><p>列表和字符串的区别：</p><ul><li>列表有 <strong>可修改性</strong> ，字符串没有</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><strong>集</strong>（set）是由零个或多个不可修改的 Python 数据对象组成的无序集合。集不允许重复元素，并且写成由花括号包含、以逗号分隔的一系列值。空集由 <code>set()</code> 来表示。集是异构的，并且可以通过下面的方法赋给变量。</p><h4 id="Python-集支持的运算"><a href="#Python-集支持的运算" class="headerlink" title="Python 集支持的运算"></a>Python 集支持的运算</h4><table><thead><tr><th>运算名</th><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td>成员</td><td><code>in</code></td><td>询问集中是否有某元素</td></tr><tr><td>长度</td><td><code>len</code></td><td>获取集的元素个数</td></tr><tr><td><code>|</code></td><td><code>aset | otherset</code></td><td>返回一个包含 <code>aset</code> 与 <code>otherset</code> 所有元素的新集</td></tr><tr><td><code>&amp;</code></td><td><code>aset &amp; otherset</code></td><td>返回一个包含 <code>aset</code> 与 <code>otherset</code> 共有元素的新集</td></tr><tr><td><code>-</code></td><td><code>aset - otherset</code></td><td>返回一个集，其中包含只出现在 <code>aset</code> 中的元素</td></tr><tr><td><code>&lt;=</code></td><td><code>aset &lt;= otherset</code></td><td>询问 <code>aset</code> 中的所有元素是否都在 <code>otherset</code> 中</td></tr></tbody></table><h4 id="Python-集提供的方法"><a href="#Python-集提供的方法" class="headerlink" title="Python 集提供的方法"></a>Python 集提供的方法</h4><table><thead><tr><th>方法名</th><th>用法</th><th>解释</th></tr></thead><tbody><tr><td><code>union</code></td><td><code>aset.union(otherset)</code></td><td>返回一个包含 <code>aset</code> 和 <code>otherset</code> 所有元素的集</td></tr><tr><td><code>intersection</code></td><td><code>aset.intersection(otherset)</code></td><td>返回一个仅包含两个集共有元素的集</td></tr><tr><td><code>difference</code></td><td><code>aset.difference(otherset)</code></td><td>返回一个集，其中仅包含只出现在 <code>aset</code> 中的元素</td></tr><tr><td><code>issubset</code></td><td><code>aset.issubset(otherset)</code></td><td>询问 <code>aset</code> 是否为 <code>otherset</code> 的子集</td></tr><tr><td><code>add</code></td><td><code>aset.add(item)</code></td><td>向 <code>aset</code> 添加一个元素</td></tr><tr><td><code>remove</code></td><td><code>aset.remove(item)</code></td><td>将 <code>item</code> 从 <code>aset</code> 中移除</td></tr><tr><td><code>pop</code></td><td><code>aset.pop()</code></td><td>随机移除 <code>aset</code> 中的一个元素</td></tr><tr><td><code>clear</code></td><td><code>aset.clear()</code></td><td>清除 <code>aset</code> 中的所有元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet</span><br><span class="line">&#123;<span class="literal">False</span>, <span class="number">4.5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="string">&#x27;cat&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yourSet = &#123;<span class="number">99</span>,<span class="number">3</span>,<span class="number">100</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet.union(yourSet)</span><br><span class="line">&#123;<span class="literal">False</span>, <span class="number">4.5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet | yourSet</span><br><span class="line">&#123;<span class="literal">False</span>, <span class="number">4.5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet.intersection(yourSet)</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet &amp; yourSet</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet.difference(yourSet)</span><br><span class="line">&#123;<span class="literal">False</span>, <span class="number">4.5</span>, <span class="number">6</span>, <span class="string">&#x27;cat&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet - yourSet</span><br><span class="line">&#123;<span class="literal">False</span>, <span class="number">4.5</span>, <span class="number">6</span>, <span class="string">&#x27;cat&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">3</span>,<span class="number">100</span>&#125;.issubset(yourSet)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">3</span>,<span class="number">100</span>&#125;&lt;=yourSet</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet.add(<span class="string">&quot;house&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet</span><br><span class="line">&#123;<span class="literal">False</span>, <span class="number">4.5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="string">&#x27;house&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet.remove(<span class="number">4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet</span><br><span class="line">&#123;<span class="literal">False</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="string">&#x27;house&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet.pop()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="string">&#x27;house&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySet</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><strong>字典</strong> 是无序结构，由相关的元素对构成，其中每对元素都由一个键和一个值组成。这种键–值对通常写成键:值的形式。字典由花括号包含的一系列以逗号分隔的键–值对表达，如下所示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>capitals = &#123;<span class="string">&#x27;Iowa&#x27;</span>:<span class="string">&#x27;DesMoines&#x27;</span>,<span class="string">&#x27;Wisconsin&#x27;</span>:<span class="string">&#x27;Madison&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>capitals&#123;<span class="string">&#x27;Wisconsin&#x27;</span>:<span class="string">&#x27;Madison&#x27;</span>, <span class="string">&#x27;Iowa&#x27;</span>:<span class="string">&#x27;DesMoines&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>可以通过键访问其对应的值，也可以向字典添加新的键–值对。<br>访问字典的语法与访问序列的语法十分相似，只不过是使用键来访问，而不是下标。添加新值也类似。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>capitals[<span class="string">&#x27;Iowa&#x27;</span>] = <span class="string">&#x27;DesMoines&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>capitals[<span class="string">&#x27;Utah&#x27;</span>] = <span class="string">&#x27;SaltLakeCity&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>capitals&#123;<span class="string">&#x27;Utah&#x27;</span>:<span class="string">&#x27;SaltLakeCity&#x27;</span>, <span class="string">&#x27;Wisconsin&#x27;</span>:<span class="string">&#x27;Madison&#x27;</span>, <span class="string">&#x27;Iowa&#x27;</span>:<span class="string">&#x27;DesMoines&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>capitals[<span class="string">&#x27;California&#x27;</span>]=<span class="string">&#x27;Sacramento&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>capitals&#123;<span class="string">&#x27;Utah&#x27;</span>:<span class="string">&#x27;SaltLakeCity&#x27;</span>, <span class="string">&#x27;Wisconsin&#x27;</span>:<span class="string">&#x27;Madison&#x27;</span>, <span class="string">&#x27;Iowa&#x27;</span>:<span class="string">&#x27;DesMoines&#x27;</span>, <span class="string">&#x27;California&#x27;</span>:<span class="string">&#x27;Sacramento&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(capitals)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br></pre></td></tr></table></figure><p>需要谨记，字典并不是根据键来进行有序维护的。第一个添加的键–值对（<code>&#39;Utah&#39;:&#39;SaltLakeCity&#39;</code>）被放在了字典的第一位，第二个添加的键–值对（<code>&#39;California&#39;:&#39;Sacramento&#39;</code>）则被放在了最后。</p><h4 id="字典的运算"><a href="#字典的运算" class="headerlink" title="字典的运算"></a>字典的运算</h4><p><code>keys</code>、<code>values</code> 和 <code>items</code> 方法均会返回包含相应值的对象。可以使用 <code>list</code> 函数将字典转换成列表。</p><table><thead><tr><th>运算名</th><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td><code>[]</code></td><td><code>myDict[k]</code></td><td>返回与 <code>k</code> 相关联的值，如果没有则报错</td></tr><tr><td><code>in</code></td><td><code>key in adict</code></td><td>如果 <code>key</code> 在字典中，返回 <code>True</code>，否则返回 <code>False</code></td></tr><tr><td><code>del</code></td><td><code>del adict[key]</code></td><td>从字典中删除 <code>key</code> 的键–值对</td></tr></tbody></table><h4 id="字典的方法"><a href="#字典的方法" class="headerlink" title="字典的方法"></a>字典的方法</h4><p><code>get</code> 方法有两种版本。如果键没有出现在字典中，<code>get</code> 会返回 <code>None</code>。然而，第二个可选参数可以返回特定值。</p><table><thead><tr><th>方法名</th><th>用法</th><th>解释</th></tr></thead><tbody><tr><td><code>keys</code></td><td><code>adict.keys()</code></td><td>返回包含字典中所有键的 <code>dict_keys</code> 对象</td></tr><tr><td><code>values</code></td><td><code>adict.values()</code></td><td>返回包含字典中所有值的 <code>dict_values</code> 对象</td></tr><tr><td><code>items</code></td><td><code>adict.items()</code></td><td>返回包含字典中所有键–值对的 <code>dict_items</code> 对象</td></tr><tr><td><code>get</code></td><td><code>adict.get(k)</code></td><td>返回 <code>k</code> 对应的值，如果没有则返回 <code>None</code></td></tr><tr><td><code>get</code></td><td><code>adict.get(k, alt)</code></td><td>返回 <code>k</code> 对应的值，如果没有则返回 <code>alt</code></td></tr></tbody></table><h4 id="字典实例"><a href="#字典实例" class="headerlink" title="字典实例"></a>字典实例</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phoneext=&#123;<span class="string">&#x27;david&#x27;</span>:<span class="number">1410</span>, <span class="string">&#x27;brad&#x27;</span>:<span class="number">1137</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phoneext</span><br><span class="line">&#123;<span class="string">&#x27;brad&#x27;</span>:<span class="number">1137</span>, <span class="string">&#x27;david&#x27;</span>:<span class="number">1410</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phoneext.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;brad&#x27;</span>, <span class="string">&#x27;david&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(phoneext.keys())</span><br><span class="line">[<span class="string">&#x27;brad&#x27;</span>, <span class="string">&#x27;david&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phoneext.values()</span><br><span class="line">dict_values([<span class="number">1137</span>, <span class="number">1410</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(phoneext.values())</span><br><span class="line">[<span class="number">1137</span>, <span class="number">1410</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phoneext.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;brad&#x27;</span>, <span class="number">1137</span>), (<span class="string">&#x27;david&#x27;</span>, <span class="number">1410</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(phoneext.items())</span><br><span class="line">[(<span class="string">&#x27;brad&#x27;</span>, <span class="number">1137</span>), (<span class="string">&#x27;david&#x27;</span>, <span class="number">1410</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phoneext.get(<span class="string">&quot;kent&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phoneext.get(<span class="string">&quot;kent&quot;</span>, <span class="string">&quot;NO ENTRY&quot;</span>)</span><br><span class="line"><span class="string">&#x27;NO ENTRY&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>程序经常要和用户进行交互。</p><p>目前的大多数程序使用对话框作为要求用户提供某种输入的方式。尽管 Python 确实有方法来创建这样的对话框，但是可以利用更简单的函数。Python 提供了一个函数，它使得我们可以要求用户输入数据并且返回一个字符串的引用。这个函数就是 <code>input</code>。</p><h3 id="提示字符串"><a href="#提示字符串" class="headerlink" title="提示字符串"></a>提示字符串</h3><p><code>input</code> 函数接受一个字符串作为参数。由于该字符串包含有用的文本来提示用户输入，因此它经常被称为 <strong>提示字符串</strong>。举例来说，可以像下面这样调用 <code>input</code>。</p><p>不论用户在提示字符串后面输入什么内容，都会被存储在 <code>aName</code> 变量中。使用 <code>input</code> 函数，可以非常简便地写出程序，让用户输入数据，然后再对这些数据进行进一步处理。例如，在下面的两条语句中，第一条要求用户输入姓名，第二条则打印出对输入字符串进行一些简单处理后的结果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aName = <span class="built_in">input</span>(<span class="string">&quot;Please enter your name &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your name in all capitals is &quot;</span>,</span><br><span class="line">        aName.upper(),</span><br><span class="line">        <span class="string">&quot;and has length&quot;</span>,</span><br><span class="line">        <span class="built_in">len</span>(aName))</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>input</code> 函数返回的值是一个字符串，它包含用户在提示字符串后面输入的所有字符。如果需要将这个字符串转换成其他类型，必须明确地提供类型转换。在下面的语句中，用户输入的字符串被转换成了浮点数，以便于后续的算术处理。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sradius = <span class="built_in">input</span>(<span class="string">&quot;Please enter the radius of the circle &quot;</span>)</span><br><span class="line">radius = <span class="built_in">float</span>(sradius)</span><br><span class="line">diameter = <span class="number">2</span> * radius</span><br></pre></td></tr></table></figure><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p><code>print</code> 函数为输出 Python 程序的值提供了一种非常简便的方法。它接受零个或者多个参数，并且将单个空格作为默认分隔符来显示结果。通过设置 <code>sep</code> 这一实际参数可以改变分隔符。此外，每一次打印都默认以换行符结尾。这一行为可以通过设置实际参数 <code>end</code> 来更改。下面是一些例子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">Hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>)</span><br><span class="line">Hello World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>, sep=<span class="string">&quot;***&quot;</span>)</span><br><span class="line">Hello***World</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>, end=<span class="string">&quot;***&quot;</span>)</span><br><span class="line">Hello World***</span><br></pre></td></tr></table></figure><p>Python 提供了另一种叫作 <strong>格式化字符串</strong> 的方式。格式化字符串是一个模板，其中包含保持不变的单词或空格，以及之后插入的变量的占位符。例如，下面的语句包含 <code>is</code> 和 <code>years old.</code>，但是名字和年龄会根据运行时变量的值而发生改变。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(aName, <span class="string">&quot;is&quot;</span>, age, <span class="string">&quot;years old.&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用格式化字符串，可以将上面的语句重写成下面的语句。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s is %d years old.&quot;</span> % (aName, age))</span><br></pre></td></tr></table></figure><h4 id="格式化字符串可用的类型声明"><a href="#格式化字符串可用的类型声明" class="headerlink" title="格式化字符串可用的类型声明"></a>格式化字符串可用的类型声明</h4><p><code>%</code> 是字符串运算符，被称作 <strong>格式化运算符</strong>。</p><p>表达式的左边部分是模板（也叫格式化字符串），右边部分则是一系列用于格式化字符串的值。</p><p>格式化字符串可以包含一个或者多个转换声明。转换字符告诉格式化运算符，什么类型的值会被插入到字符串中的相应位置。</p><p>在上面的例子中，<code>%s</code> 声明了一个字符串，<code>%d</code> 则声明了一个整数。其他可能的类型声明还包括 <code>i</code>、<code>u</code>、<code>f</code>、<code>e</code>、<code>g</code>、<code>c</code> 和 <code>%</code>。</p><table><thead><tr><th>字符</th><th>输出格式</th></tr></thead><tbody><tr><td><code>d</code>、<code>i</code></td><td>整数</td></tr><tr><td><code>u</code></td><td>无符号整数</td></tr><tr><td><code>f</code></td><td>m.dddd 格式的浮点数</td></tr><tr><td><code>e</code></td><td>m.dddde+&#x2F;-xx 格式的浮点数</td></tr><tr><td><code>E</code></td><td>m.ddddE+&#x2F;-xx 格式的浮点数</td></tr><tr><td><code>g</code></td><td>对指数小于-4 或者大于 5 的使用 <code>%e</code>，否则使用 <code>%f</code></td></tr><tr><td><code>c</code></td><td>单个字符</td></tr><tr><td><code>s</code></td><td>字符串，或者任意可以通过 <code>str</code> 函数转换成字符串的 Python 数据对象</td></tr><tr><td><code>%</code></td><td>插入一个常量 <code>%</code> 符号</td></tr></tbody></table><h4 id="格式化修改符"><a href="#格式化修改符" class="headerlink" title="格式化修改符"></a>格式化修改符</h4><table><thead><tr><th>修改符</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>数字</td><td><code>%20d</code></td><td>将值放在 20 个字符宽的区域中</td></tr><tr><td><code>-</code></td><td><code>%-20d</code></td><td>将值放在 20 个字符宽的区域中，并且左对齐</td></tr><tr><td><code>+</code></td><td><code>%+20d</code></td><td>将值放在 20 个字符宽的区域中，并且右对齐</td></tr><tr><td><code>0</code></td><td><code>%020d</code></td><td>将值放在 20 个字符宽的区域中，并在前面补上 0</td></tr><tr><td><code>.</code></td><td><code>%20.2f</code></td><td>将值放在 20 个字符宽的区域中，并且保留小数点后 2 位</td></tr><tr><td><code>(name)</code></td><td><code>%(name)d</code></td><td>从字典中获取 <code>name</code> 键对应的值</td></tr></tbody></table><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>price = <span class="number">24</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item = <span class="string">&quot;banana&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;The %s costs %d cents&quot;</span> % (item,price))</span><br><span class="line">The banana costs <span class="number">24</span> cents</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;The %+10s costs %5.2f cents&quot;</span> % (item,price))</span><br><span class="line">The     banana costs <span class="number">24.00</span> cents</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;The %+10s costs %10.2f cents&quot;</span> % (item,price))</span><br><span class="line">The     banana costs     <span class="number">24.00</span> cents</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemdict = &#123;<span class="string">&quot;item&quot;</span>:<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;cost&quot;</span>:<span class="number">24</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;The %(item)s costs %(cost)7.1f cents&quot;</span> % itemdict)</span><br><span class="line">The banana costs    <span class="number">24.0</span> cents</span><br></pre></td></tr></table></figure><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>Python提供的标准的标准控制语句有 <code>while</code> 语句以及 <code>for</code> 语句。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counter = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> counter &lt;= <span class="number">5</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line"><span class="meta">... </span>    counter = counter + <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Hello, world</span><br><span class="line">Hello, world</span><br><span class="line">Hello, world</span><br><span class="line">Hello, world</span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure><p>看下面这个例子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> counter &lt;= <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">not</span> done:</span><br></pre></td></tr></table></figure><p>迭代语句只有在上面两个条件都满足的情况下才会被执行。变量 <code>counter</code> 的值需要小于或等于 10，并且变量 <code>done</code> 的值需要为 <code>False</code>（<code>not False</code> 就是 <code>True</code>），因此 <code>True and True</code> 的最后结果才是 <code>True</code>。</p><p><code>for</code>在遍历每一个成员上非常的方便。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>]:</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(item)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="列表解析式"><a href="#列表解析式" class="headerlink" title="列表解析式"></a>列表解析式</h3><p>列表可以通过使用迭代结构和分支结构来创建。这种方式被称为 <strong>列表解析式</strong>。通过列表解析式，可以根据一些处理和分支标准轻松创建列表。</p><p>举例来说，如果想创建一个包含前 10 个完全平方数的列表，可以使用以下的 <code>for</code> 语句。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlist = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">         sqlist.append(x*x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlist</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>进阶：使用列表解析式，只需一行代码即可创建完成。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlist</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>进阶：变量 <code>x</code> 会依次取由 <code>for</code> 语句指定的 1 到 10 为值。之后，计算 <code>x*x</code> 的值并将结果添加到正在构建的列表中。列表解析式也允许添加一个分支语句来控制添加到列表中的元素。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x%<span class="number">2</span> != <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sqlist</span><br><span class="line">[<span class="number">1</span>, <span class="number">9</span>, <span class="number">25</span>, <span class="number">49</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>例子：（力扣的原题：输出列表中非元音的字母并以大写形式返回）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;[ch.upper() <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;comprehension&#x27;</span> <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;aeiou&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;N&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>下面定义的简单函数会返回传入值的平方。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">n</span>):</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(square(<span class="number">3</span>))</span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><p>同样的，我们可以自己定义一个平方根函数 <code>squareroot()</code> </p><blockquote><p>通过牛顿迭代法求解平方根</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">def</span> <span class="title function_">squareroot</span>(<span class="params">n</span>):</span><br><span class="line"><span class="number">2.</span>      root = n/<span class="number">2</span> <span class="comment">#initial guess will be 1/2 of n</span></span><br><span class="line"><span class="number">3.</span>      <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line"><span class="number">4.</span>          root = (<span class="number">1</span>/<span class="number">2</span>)*(root + (n / root))</span><br><span class="line"><span class="number">5.</span></span><br><span class="line"><span class="number">6.</span>      <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>接下来，模拟调用这个函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squareroot(<span class="number">9</span>)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squareroot(<span class="number">4563</span>)</span><br><span class="line"><span class="number">67.549981495186216</span></span><br></pre></td></tr></table></figure><h2 id="面向对象：定义-类"><a href="#面向对象：定义-类" class="headerlink" title="面向对象：定义 类"></a>面向对象：定义 <code>类</code></h2><h1 id="算法分析相关"><a href="#算法分析相关" class="headerlink" title="算法分析相关"></a>算法分析相关</h1><h2 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h2><h3 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 <code>O</code> 表示法</h3><blockquote><p>如果可以通过观察循环结构和算法的方式快速判断出复杂度就算出师</p></blockquote><p>异序词排序问题</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">anagramSolution1</span>(<span class="params">s1, s2</span>):</span><br><span class="line">   alist = <span class="built_in">list</span>(s2)</span><br><span class="line"></span><br><span class="line">   pos1 = <span class="number">0</span></span><br><span class="line">   StillOK = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> pos1 &lt; <span class="built_in">len</span>(s1) <span class="keyword">and</span> stillOK:</span><br><span class="line">      pos2 = <span class="number">0</span></span><br><span class="line">      found = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">while</span> pos2 &lt; <span class="built_in">len</span>(alist) <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">         <span class="keyword">if</span> s1[pos1] == alist[pos2]:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            pos2 += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> found:</span><br><span class="line">         alist[pos2] = <span class="literal">None</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         stillOK = <span class="literal">False</span></span><br><span class="line">      </span><br><span class="line">      pos1 += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> stillOK</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">anagramSolution2</span>(<span class="params">s1, s2</span>):</span><br><span class="line">   alist1 = <span class="built_in">list</span>(s1)</span><br><span class="line">   alist2 = <span class="built_in">list</span>(s2)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 这里需要记住，常用的几类排序时间复杂度在 O(n^2) 或 O(nlogn)</span></span><br><span class="line">   alist1.sort()</span><br><span class="line">   alist2.sort()</span><br><span class="line"></span><br><span class="line">   pos = <span class="number">0</span></span><br><span class="line">   matches = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> pos &lt; <span class="built_in">len</span>(s1) <span class="keyword">and</span> matches:</span><br><span class="line">      <span class="keyword">if</span> alist1[pos] == alist2[pos]:</span><br><span class="line">         pos += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         matches = <span class="literal">False</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> matches</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">anagramSolution3</span>(<span class="params">s1, s2</span>):</span><br><span class="line">   c1 = [<span class="number">0</span>] * n</span><br><span class="line">   c2 = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line">      pos = <span class="built_in">ord</span>(s1[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">      c1[pos] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">      pos = <span class="built_in">ord</span>(s2[i] - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">      c2[pos] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   j = <span class="number">0</span></span><br><span class="line">   stillOk = <span class="literal">True</span></span><br><span class="line">   <span class="keyword">while</span> j &lt; <span class="number">26</span> <span class="keyword">and</span> stillOK:</span><br><span class="line">      <span class="keyword">if</span> c1[j] == c2[j]:</span><br><span class="line">         j += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">         stillOK = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> stillOk</span><br></pre></td></tr></table></figure><p>第四个例子是最快的。因为没有循环嵌套，只有<code>O(n)</code>的复杂度。倘若需要考虑关于空间上的需求，那么第四个例子新开了额外的空间用于存储计数器，这种方式就是常说的：空间换时间的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3&quot;&gt;算法分析相关&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zade23.github.io/categories/Algorithm/"/>
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>完备区间判断下的二分查找万能模板</title>
    <link href="https://zade23.github.io/2023/07/07/%E5%AE%8C%E5%A4%87%E5%8C%BA%E9%97%B4%E5%88%A4%E6%96%AD%E4%B8%8B%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%87%E8%83%BD%E6%A8%A1%E6%9D%BF/"/>
    <id>https://zade23.github.io/2023/07/07/%E5%AE%8C%E5%A4%87%E5%8C%BA%E9%97%B4%E5%88%A4%E6%96%AD%E4%B8%8B%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%87%E8%83%BD%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-07-07T06:57:15.000Z</published>
    <updated>2024-03-14T03:01:45.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>单调数列&#x2F;数组 一定可以用二分；但如果非单调的情况，也有可能存在能够使用二分的情况</p><hr><h2 id="二分模板"><a href="#二分模板" class="headerlink" title="二分模板"></a>二分模板</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数二分的模板</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/*......*/</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目前发现整数二分的所有情况都可以被下面的两个板子涵盖</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1.1 区间被划分成 [l, mid] 和 [mid + 1， r]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1.2 区间被划分成 [l, mid - 1] 和 [mid, r]</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">bsearch_2</span>(<span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chedk</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  二分查找</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x</span>):  <span class="comment"># 判断x是否满足某种性质</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1.1 区间被划分成 [l, mid] 和 [mid + 1， r]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bsearch_2</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)):</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1.2 区间被划分成 [l, mid - 1] 和 [mid, r]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bsearch_1</span>(<span class="params">l, r</span>):</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)):</span><br><span class="line">            l = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><p>只有C++要考虑，高贵的Python不需要考虑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;单调数列&amp;#x2F;数组 一定可以用二分；但如果非单调的情况，也有可能存在能够使用二分的情况&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二分模板&quot;&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zade23.github.io/categories/Algorithm/"/>
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
    <category term="C++" scheme="https://zade23.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Python条件判断的优先级</title>
    <link href="https://zade23.github.io/2023/07/06/Python%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://zade23.github.io/2023/07/06/Python%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2023-07-06T12:53:13.000Z</published>
    <updated>2024-03-14T02:59:07.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做LeetCode的时候经常能够发现很多基本功不扎实的问题。<br>这一次是在做一道简单题时候忽视的<strong>条件判断</strong>优先级的问题</p><blockquote><p>题目连接：<a href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range">https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range</a></p></blockquote><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><hr><h3 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">vowelStrings</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        words = words[left : right + <span class="number">1</span>]</span><br><span class="line">        n = <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span> <span class="keyword">and</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">vowelStrings</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        words = words[left : right + <span class="number">1</span>]</span><br><span class="line">        n = <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>二者的差别就在如何衔接 <code>or</code> 和 <code>and</code> 之间的关系上。</p><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>分析错误代码的bug：</p><p>在第二段错误代码中，条件判断部分存在问题。以下是有问题的代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span> <span class="keyword">and</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">    res += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>问题出在逻辑运算符的优先级上。在Python中，<code>and</code> 运算符的优先级高于 <code>or</code> 运算符，因此该条件判断实际上被解释为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> (words[i][<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span> <span class="keyword">and</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>) <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">    res += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于 <code>or</code> 运算符的短路特性，只要 <code>words[i][0]</code> 的首字母为元音字母之一，整个条件判断就会被认为是True，导致res增加。而第二个部分 <code>words[i][-1] == &#39;a&#39;</code>、<code>words[i][-1] == &#39;e&#39;</code>等都是单独的条件，不会影响整个条件判断的结果。</p><p>修正该bug的方法是使用括号明确指定条件的分组，确保逻辑关系正确。以下是修正后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (words[i][<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span>) <span class="keyword">and</span> (words[i][-<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> <span class="keyword">or</span> words[i][-<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span>):</span><br><span class="line">    res += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样修改后，条件判断会首先检查首字母是否为元音字母，然后再检查末尾字母是否为元音字母，两个条件都满足时才会增加res的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;做LeetCode的时候经常能够发现很多基本功不扎实的问题。&lt;br&gt;这一次是在做一道简单题时候忽视的&lt;strong&gt;条件判断&lt;/strong</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zade23.github.io/categories/Algorithm/"/>
    
    
    <category term="Python" scheme="https://zade23.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zade23.github.io/2023/05/16/hello-world/"/>
    <id>https://zade23.github.io/2023/05/16/hello-world/</id>
    <published>2023-05-16T09:45:58.000Z</published>
    <updated>2024-03-20T13:42:07.174Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><blockquote><p>如果公式出现渲染失败的情况，请<strong>将公式中下划线后面加上空格</strong>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="whatever" scheme="https://zade23.github.io/categories/whatever/"/>
    
    
    <category term="Hexo" scheme="https://zade23.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
